<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>No Overhead Autoconfiguration OLSR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="No Overhead Autoconfiguration OLSR">
<meta name="keywords" content="OLSR, autoconfiguration">
<meta name="generator" content="xml2rfc v1.25 (http://xml.resource.org/)">
<style type='text/css'>
<!--
    body {
        font-family: verdana, charcoal, helvetica, arial, sans-serif;
        margin: 2em;
        font-size: small ; color: #000000 ; background-color: #ffffff ; }
    .title { color: #990000; font-size: x-large ;
        font-weight: bold; text-align: right;
        font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
        background-color: transparent; }
    .filename { color: #666666; font-size: 18px; line-height: 28px;
        font-weight: bold; text-align: right;
        font-family: helvetica, arial, sans-serif;
        background-color: transparent; }
    td.rfcbug { background-color: #000000 ; width: 30px ; height: 30px ; 
        text-align: justify; vertical-align: middle ; padding-top: 2px ; }
    td.rfcbug span.RFC { color: #666666; font-weight: bold; text-decoration: none;
        background-color: #000000 ;
        font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
        font-size: x-small ; }
    td.rfcbug span.hotText { color: #ffffff; font-weight: normal; text-decoration: none;
        text-align: center ;
        font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
        font-size: x-small ; background-color: #000000; }
/* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
    div#counter{margin-top: 100px}

    a.info{
        position:relative; /*this is the key*/
        z-index:24;
        text-decoration:none}

    a.info:hover{z-index:25; background-color:#990000 ; color: #ffffff ;}

    a.info span{display: none}

    a.info:hover span{ /*the span will display just on :hover state*/
        display:block;
        position:absolute;
        font-size: smaller ;
        top:2em; left:2em; width:15em;
        padding: 2px ;
        border:1px solid #333333;
        background-color:#eeeeee; color:#990000;
        text-align: left ;}

     A { font-weight: bold; }
     A:link { color: #990000; background-color: transparent ; }
     A:visited { color: #333333; background-color: transparent ; }
     A:active { color: #333333; background-color: transparent ; }

    p { margin-left: 2em; margin-right: 2em; }
    p.copyright { font-size: x-small ; }
    p.toc { font-size: small ; font-weight: bold ; margin-left: 3em ;}

    span.emph { font-style: italic; }
    span.strong { font-weight: bold; }
    span.verb { font-family: "Courier New", Courier, monospace ; }

    ol.text { margin-left: 2em; margin-right: 2em; }
    ul.text { margin-left: 2em; margin-right: 2em; }
    li { margin-left: 3em;  }

    pre { margin-left: 3em; color: #333333;  background-color: transparent;
        font-family: "Courier New", Courier, monospace ; font-size: small ;
        }

    h3 { color: #333333; font-size: medium ;
        font-family: helvetica, arial, sans-serif ;
        background-color: transparent; }
    h4 { font-size: small; font-family: helvetica, arial, sans-serif ; }

    table.bug { width: 30px ; height: 15px ; }
    td.bug { color: #ffffff ; background-color: #990000 ;
        text-align: center ; width: 30px ; height: 15px ;
         }
    td.bug A.link2 { color: #ffffff ; font-weight: bold;
        text-decoration: none;
        font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
        font-size: x-small ; background-color: transparent }

    td.header { color: #ffffff; font-size: x-small ;
        font-family: arial, helvetica, sans-serif; vertical-align: top;
        background-color: #666666 ; width: 33% ; }
    td.author { font-weight: bold; margin-left: 4em; font-size: x-small ; }
    td.author-text { font-size: x-small; }
    table.data { vertical-align: top ; border-collapse: collapse ;
        border-style: solid solid solid solid ;
        border-color: black black black black ;
        font-size: small ; text-align: center ; }
    table.data th { font-weight: bold ;
        border-style: solid solid solid solid ;
        border-color: black black black black ; }
    table.data td {
        border-style: solid solid solid solid ;
        border-color: #333333 #333333 #333333 #333333 ; }

    hr { height: 1px }
-->
</style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">MANET</td><td class="header">Pr. Mase</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">C. Adjih</td></tr>
<tr><td class="header">Expires: August 22, 2005</td><td class="header">Information and Communication</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">Network Lab., Niigata University</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">February 21, 2005</td></tr>
</table></td></tr></table>
<div align="right"><span class="title"><br />No Overhead Autoconfiguration OLSR</span></div>
<div align="right"><span class="title"><br />draft-mase-manet-autoconf-noaolsr-00</span></div>

<h3>Status of this Memo</h3>
<p>
This document is an Internet-Draft and is subject to all provisions
of section 3 of RFC 3667.
By submitting this Internet-Draft,
each author represents that any applicable patent or other IPR claims of which
he or she is aware have been or will be disclosed,
and any of which he or she become aware will be disclosed,
in accordance with RFC 3668.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF), its areas, and its working groups.
Note that other groups may also distribute working documents as
Internet-Drafts.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as "work in progress."</p>
<p>
The list of current Internet-Drafts can be accessed at
<a href='http://www.ietf.org/ietf/1id-abstracts.txt'>http://www.ietf.org/ietf/1id-abstracts.txt</a>.</p>
<p>
The list of Internet-Draft Shadow Directories can be accessed at
<a href='http://www.ietf.org/shadow.html'>http://www.ietf.org/shadow.html</a>.</p>
<p>
This Internet-Draft will expire on August 22, 2005.</p>

<h3>Copyright Notice</h3>
<p>
Copyright (C) The Internet Society (2005).</p>

<h3>Abstract</h3>

<p>

This document specifies one method for autoconfiguration 
 for the
Optimized Link State Routing (OLSR) protocol
for ad hoc networks. OLSR is a routing protocol for mobile ad hoc
networks, designed for use in multi-hop wireless ad hoc networks ; and as
such it specifies how individual nodes can construct
routes to each other. To achieve this, it relies on
preliminary assignment of unique IP addresses to OLSR interfaces ;
hence the task of assigning addresses to interfaces, and checking
their uniqueness is defined externally.
This document proposes a complementary
method, called "No Overhead Autoconfiguration for OLSR" (NOA-OLSR),
to perform this task of ensuring
uniqueness (Duplicate Address Detection, DAD) of addresses which have
been selected.
This method consists of modifications in the OLSR specification.

</p><a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#anchor1">1.</a>&nbsp;
Introduction<br />
<a href="#sec:overview">2.</a>&nbsp;
Autoconfiguration Method Overview<br />
<a href="#sec:terminology">3.</a>&nbsp;
Terminology<br />
<a href="#sec:algorithm">4.</a>&nbsp;
Autoconfiguration Algorithms<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:algorithm-overview">4.1</a>&nbsp;
Overview<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:address-selection">4.2</a>&nbsp;
Address Selection<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:dad">4.3</a>&nbsp;
Duplicate Address Detection<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:dad.overview">4.3.1</a>&nbsp;
Overview<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:dad-rule-notation">4.3.2</a>&nbsp;
Notation<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:dad.1hop">4.3.3</a>&nbsp;
Neighbor Duplicate Address Detection<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rule:R1">4.3.3.1</a>&nbsp;
Rule R1<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:dad.2hop">4.3.4</a>&nbsp;
Two-hop duplicate address detection<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rule:R2">4.3.4.1</a>&nbsp;
Rule R2<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rule:R3">4.3.4.2</a>&nbsp;
Rule R3<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:dad.nhop">4.3.5</a>&nbsp;
Multihop duplicate address detection<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:dad.nhop.tc-tc">4.3.5.1</a>&nbsp;
Multihop DAD with two TC generators<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:dad.nhop.notc-notc">4.3.5.2</a>&nbsp;
Multihop DAD with two non-generators<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor2">4.3.5.3</a>&nbsp;
Multihop DAD with one TC Generator and one Non-Generator<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor3">4.3.5.4</a>&nbsp;
Three-hop DAD, Specific Case<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:seq-num-consistency">4.4</a>&nbsp;
Sequence Number Consistency<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor4">4.4.1</a>&nbsp;
Minimum Wrap-Around Limit<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:hello-consistency">4.4.2</a>&nbsp;
HELLO Sequence Number Consistency<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:tc-consistency">4.4.3</a>&nbsp;
TC Sequence Number Consistency<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:state">4.5</a>&nbsp;
Autoconfiguration State<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:state.overview">4.5.1</a>&nbsp;
Introduction<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:state.functionning">4.5.2</a>&nbsp;
Functionning<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:familiarity">4.6</a>&nbsp;
Node Familiarity<br />
<a href="#sec:specification">5.</a>&nbsp;
Autoconfiguration Specifications<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:specification-overview">5.1</a>&nbsp;
Overview<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:repository">5.2</a>&nbsp;
Information Repository<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor5">5.2.1</a>&nbsp;
Autoconfiguration State<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor6">5.2.2</a>&nbsp;
State Information Base<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:duplicate-set">5.2.3</a>&nbsp;
Duplicate Set<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:content-identifier">5.2.3.1</a>&nbsp;
Message Content Identifier<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:set-field">5.2.4</a>&nbsp;
Set and Unset Fields<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:spec-selection">5.3</a>&nbsp;
Address Selection and Address Change<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:spec-address-selection">5.3.1</a>&nbsp;
Address Selection<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:spec-address-change">5.3.2</a>&nbsp;
Address Change<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor7">5.4</a>&nbsp;
State Set Update<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:state-set-population">5.4.1</a>&nbsp;
Populating the State Set<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:state-tuple-update">5.4.2</a>&nbsp;
State Tuple Update<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:state-tuple-retrieve">5.4.3</a>&nbsp;
Associated State Tuple Retrieval<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor8">5.4.4</a>&nbsp;
State Tuple: HELLO information update<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor9">5.4.5</a>&nbsp;
State Tuple: TC information update<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:state-mpr-remember">5.4.6</a>&nbsp;
State Tuple: MPR information update<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:spec-familiarity">5.4.7</a>&nbsp;
Familiarity<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#XXX-1">5.5</a>&nbsp;
Changes in Message Processing<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#XXX-2">5.5.1</a>&nbsp;
Overview<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:spec-processing">5.5.2</a>&nbsp;
Packet Processing and Message Flooding<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:special-retransmission">5.5.2.1</a>&nbsp;
Special Retransmission<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:special-duplicate">5.5.2.2</a>&nbsp;
Special Duplicate Tuple Creation<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:pre-processing">5.5.3</a>&nbsp;
Autoconfiguration Message Pre-Processing<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:hello-pre-processing">5.5.3.1</a>&nbsp;
Hello Message Pre-Processing<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:tc-pre-processing">5.5.3.2</a>&nbsp;
TC Message Pre-Processing<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:post-processing">5.5.4</a>&nbsp;
Autoconfiguration Message Post-Processing<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor12">5.6</a>&nbsp;
Changes in OLSR Message Processing<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:change-hello-format">5.6.1</a>&nbsp;
Changes in HELLO Message Format<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:change-hello-processing">5.6.2</a>&nbsp;
Changes in HELLO Message Processing<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:hello-processing-state">5.6.2.1</a>&nbsp;
State Set Update from HELLO<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:change-hello-generation">5.6.3</a>&nbsp;
Changes in HELLO Message Generation<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:change-tc-format">5.6.4</a>&nbsp;
Changes in TC Message Format<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:change-tc-processing">5.6.5</a>&nbsp;
Changes in TC Message Processing<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:tc-processing-state">5.6.5.1</a>&nbsp;
State Set Update from TC<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:spec-tc-conflict">5.6.5.2</a>&nbsp;
Conflict detection based on TC message content<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:spec-tc-dismiss">5.6.5.3</a>&nbsp;
Dismissed TC messages<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:spec-tc-address-dismiss">5.6.5.4</a>&nbsp;
Dismissed addresses in TC messages<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:change-tc-generation">5.6.6</a>&nbsp;
Changes in TC Message Generation<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:spec-message-type">5.6.7</a>&nbsp;
Message Type for HELLO and TC Messages<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:change-mpr-computation">5.7</a>&nbsp;
Changes in MPR Computation<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:change-routing-table">5.8</a>&nbsp;
Changes in Routing Table Calculation<br />
<a href="#sec:constant">6.</a>&nbsp;
Proposed Values for Constants<br />
<a href="#sec:message-type-value">7.</a>&nbsp;
IANA Considerations<br />
<a href="#sec:interoperability">8.</a>&nbsp;
Limitations and interoperability considerations<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:limitations-modified">8.1</a>&nbsp;
Limitations<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:interoperability-modified">8.2</a>&nbsp;
Interoperability with Standard OLSR<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:interoperability-discussion">8.2.1</a>&nbsp;
Considerations for Interoperability with Standard OLSR<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:isolation">8.2.2</a>&nbsp;
Considerations for Isolation from Standard OLSR Nodes<br />
<a href="#anchor13">9.</a>&nbsp;
Requirements notation<br />
<a href="#sec:security">10.</a>&nbsp;
Security Considerations<br />
<a href="#anchor14">11.</a>&nbsp;
Acknowledgements<br />
<a href="#rfc.references1">12.</a>&nbsp;
References<br />
<a href="#rfc.references1">12.1</a>&nbsp;
Normative References<br />
<a href="#rfc.references2">12.2</a>&nbsp;
Informative References<br />
<a href="#rfc.authors">&#167;</a>&nbsp;
Authors' Addresses<br />
<a href="#rfc.index">&#167;</a>&nbsp;
Index<br />
<a href="#rfc.copyright">&#167;</a>&nbsp;
Intellectual Property and Copyright Statements<br />
</p>
<br clear="all" />

<a name="anchor1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;Introduction</h3>

<p>
A mobile ad hoc network is a collection of nodes, which collaborate to
each other without depending on centralized control for enabling
wireless communication among nodes. When two nodes are within direct
transmission range, they communicate directly (one hop wireless
communication) ; and otherwise they communicate using other 
nodes as intermediary nodes (multihop wireless
communication), where the intermediary nodes act as routers for
forwarding IP datagrams. Accordingly, routing is a key problem for
mobile ad hoc networks and many routing protocols have been
proposed.
In IETF, in the MANET working group, two proactive routing
protocols, OLSR <a class="info" href="#RFC3626">[3]<span>Clausen, T. and P. Jacquet, Optimized Link State Routing Protocol (OLSR), October 2003.</span></a>
and TBRPF <a class="info" href="#RFC3684">[4]<span>Ogier, R., Templin, F. and M. Lewis, Topology Dissemination Based on Reverse-Path Forwarding (TBRPF), February 2004.</span></a>, 
and two reactive routing protocols, AODV <a class="info" href="#RFC3561">[5]<span>Perkins, C., Belding-Royer, E. and S. Das, Ad hoc On-Demand Distance Vector (AODV) Routing, July 2003.</span></a>
and DSR <a class="info" href="#I-D.ietf-manet-dsr">[6]<span>Johnson, D., The Dynamic Source Routing Protocol for Mobile Ad Hoc Networks (DSR), July 2004.</span></a>
are or will progress to experimental RFC status.

However these routing protocols assume that
each node has been assigned an unique IP address on each of
its network interfaces.
IP address autoconfiguration is therefore an important pratical
issue and accordingly, many autoconfiguration methods 
for various types of MANET networks have been proposed.

</p>
<p>
Many conventional methods are
organized independently from routing protocols so that they can be
used for any MANET regardless of the routing protocols. Some other
methods are intended to work jointly with the routing protocols to
improve efficiency of IP address autoconfiguration and duplicated
address detection. For example, information about IP addresses in use
can be collected with support of the routing protocol and can be used
in selecting a new free addresses for a node seeking address allocation.

Unfortunately, all of these proposed methods are rather
expensive as they require significant control message overhead for
either avoiding or resolving address conflicts.

</p>
<p>We propose a novel IP address autoconfiguration method for MANET with
proactive routing for OLSR. Our method is an duplicate address
detection without overhead based on properties
of proactive link state routing protocols.
The algorithmic and research related aspect
can be find in the joint publication <a class="info" href="#ref:mase-autoconf">[9]<span>Mase, K., No Overhead IP Address Autoconfiguration for Mobile                  Ad Hoc Networks with Proactive Routing, Work in progress.</span></a>.

</p>
<a name="sec:overview"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;Autoconfiguration Method Overview</h3>

<p>In this section, an overview of the autoconfiguration method is given,
followed by a description of the structure of the document.
</p>
<p>The autoconfiguration algorithm detailed in this document applies to
the OLSR protocol, and changes its operation.
The node is assumed to implement the OLSR protocol (<a class="info" href="#RFC3626">[3]<span>Clausen, T. and P. Jacquet, Optimized Link State Routing Protocol (OLSR), October 2003.</span></a>,
thereafter denoted "standard OLSR"),
complemented by the modifications specified here
(thenceforth, "NOA-OLSR").
The node is also assumed to operate in a OLSR MANET environment in which 
the limitations and restrictions enumerated
in <a class="info" href="#sec:interoperability">Section 8<span>Limitations and interoperability considerations</span></a> are respected.
</p>
<p>
Under these assumptions, an OLSR node running NOA-OLSR will
proceed as follows. An address is initially selected for its OLSR
interface (manually, or using the autoconfiguration methods suggested in
this document). Then, the node runs the OLSR protocol using this address,
while at the same time constantly checking that it is not conflicting
with the address of another node in the network (using the detection
algorithm of this document).

Finally, it doesn't run fully OLSR protocol initially, because it might
be entering in a network where its address could be already used by another
node, and it would
possibly break routes of nodes which are already running. Instead,
the node goes through several states, in the last of which, only,
the node will ultimately run the full OLSR protocol.
Similarily, in order to avoid routing table contamination,
the other nodes avoid relying on this node initially,
and will rely on it for routing and forwarding messages,
when it has reached proper states. 
</p>
<p>
To sum up, the autoconfiguration of an OLSR node includes in three parts: 
</p>
<ul class="text">
<li>Address selection
</li>
<li>Ongoing duplicate address detection
</li>
<li>Gradual entry in the OLSR network and routing table contamination
avoidance
</li>
</ul>

<p>
Considering the address selection, it is actually a peripherical issue of
the protocol described in this document, because it is fairly independent
of it. Hence an overview of address selection is provided, along with
guidelines, and pointers to relevant references.

</p>
<p>
The ongoing
duplicate address detection is the main addition to the OLSR protocol,
detailed in section <a class="info" href="#sec:dad">Section 4.3<span>Duplicate Address Detection</span></a> is , checking for 
inconsistencies in the 
routing protocol messages to diagnose duplicate address detection,
using variants of the ideas pioneered by <a class="info" href="#ref:pacman">[8]<span>Weniger, K., Passive Duplicate Address Detection in Mobile Ad hoc                   Networks, March 2003.</span></a>:
</p>
<ul class="text">
<li>The first kind of inconsistency is based on information included in OLSR
  messages (such as HELLO messages and TC messages): many cases of
  duplicate address in one MANET network result into inconsistent 
  information being received ; topology information, for instance.
  
</li>
<li>The second kind of inconsistency is based on sequence
  numbers: when two nodes, which selected the same IP address, are present 
  in a network, they would send control messages that will be inconsistent.
  
</li>
</ul>

<p>Finally the protocol introduces a state for each OLSR node,
the "autoconfiguration state".
As mentioned, it allows one OLSR node with a newly selected address 
to enter gradually in running OLSR network,
by sending messages which will be used by more and more nodes.
At the same time, it also prevents
routing table calculation contamination by ensuring
that routes go through nodes which have been present in the network long
enough for the duplicate address detection to have been performed.
The description of the autoconfiguration state 
is given in section <a class="info" href="#sec:state">Section 4.5<span>Autoconfiguration State</span></a>.

</p>
<p><a name="anchor49"></a>
The description of the three parts constitutes the major part of this
document. However, they include both algorithm aspects 
(such as how and why some DAD rule is used),
and detailed specifications (such as the information bases used 
to implement the protocol). The choice was made to divide the document
in two parts: first the algorithmic part which describe the ideas
used, then the detailed specifications. 

Including some additional sections, the remaining of this document
is organized as follows:
</p>
<ul class="text">
<li><a class="info" href="#sec:terminology">Section 3<span>Terminology</span></a> collects specific terminology
used
</li>
<li><a class="info" href="#sec:algorithm">Section 4<span>Autoconfiguration Algorithms</span></a> provides the high-level, algorithmic,
part of this document. It includes:
  
<ul class="text">
<li>Address selection.
</li>
<li>Ongoing duplicate address detection.
</li>
<li>Principles behind checking sequence number consistency of messages.
</li>
<li>Gradual entry in the OLSR network and routing table contamination
  avoidance.
</li>
</ul>
</li>
<li><a class="info" href="#sec:specification">Section 5<span>Autoconfiguration Specifications</span></a> provides the specification
of NOA-OLSR. It includes:
  
<ul class="text">
<li>Description of the additions and changes to the information
  repository of OLSR.
</li>
<li>Population of (new) state set.
</li>
<li>Constraints of address selection.
</li>
<li>Changes in packet processing, in OLSR message processing 
      and OLSR message generation.
</li>
<li>Changes in MPR computation and routing table calculation.
</li>
</ul>
</li>
</ul>

<a name="sec:terminology"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;Terminology</h3>

<p>

This section provides definition for terms that have a specific meaning
to the protocol specified in this document and that are used 
throughout the text.

</p>
<blockquote class="text"><dl>
<dt>Address Conflict:</dt>
<dd><a name="anchor50"></a><a name="anchor51"></a><a name="anchor52"></a><a name="anchor53"></a>
    When two nodes in the same 
    MANET network share the same address, the situation is described as an
    "Address Conflict". The nodes involved are "conflicting nodes" and their
    shared address is called "conflicting address". Conflicting nodes may
    each send one message with the same sequence number and same 
    message type: such messages are denoted "conflicting messages".
  
</dd>
<dt>Autoconfiguration State:</dt>
<dd><a name="anchor54"></a>
    The current autoconfiguration
    state of the node, one of HELLO, TOPOLOGY, and NORMAL, 
    which indicates what messages it should (or should not)
    generate and processing it should (or should not) do
    (see <a class="info" href="#sec:state">Section 4.5<span>Autoconfiguration State</span></a>).
</dd>
<dt>Busy Address:</dt>
<dd><a name="anchor55"></a>
    An address which is being used by some node in the network
    (see <a class="info" href="#sec:address-selection">Section 4.2<span>Address Selection</span></a>).
   
</dd>
<dt>Duplicate Address Detection (DAD):</dt>
<dd><a name="anchor56"></a>
    Duplicate address detection is the action of detecting address conflict,
    the situation where some nodes
    are using the same address in the same MANET network.
  
</dd>
<dt>Duplicate Address Detection Rule (DAD Rule):</dt>
<dd><a name="anchor57"></a>
    A duplicate address detection rule is one rule of this document,
    which used to detect the existence of address conflict
    (see <a class="info" href="#sec:dad">Section 4.3<span>Duplicate Address Detection</span></a>).
  
</dd>
<dt>Familiar Address (Node):</dt>
<dd><a name="anchor58"></a><a name="anchor59"></a><a name="anchor60"></a>
    An address is familiar for a node, if the node has seen it in an
    OLSR message, for a sufficiently long period of time
    (see <a class="info" href="#sec:familiarity">Section 4.6<span>Node Familiarity</span></a> and 
    <a class="info" href="#sec:spec-familiarity">Section 5.4.7<span>Familiarity</span></a>).
    A node is familiar for another node if it has a familiar address for
    this other node. An address or a node which is not familiar is 
    said "unfamiliar".
  
</dd>
<dt>Message Content Identifier:</dt>
<dd><a name="anchor61"></a>
    A message content identifier is computed internally by the node to
    differentiate between the content of different messages,
    independently of the
    message header (see <a class="info" href="#sec:content-identifier">Section 5.2.3.1<span>Message Content Identifier</span></a>).
  
</dd>
<dt>Message Content Identifier Generation Method:</dt>
<dd><a name="anchor62"></a>
    The message content identifier generation method, is the method
    that one node implements to compute a message content identifier from
    the content of a message (see <a class="info" href="#sec:content-identifier">Section 5.2.3.1<span>Message Content Identifier</span></a>).
  
</dd>
<dt>NOA-OLSR:</dt>
<dd><a name="anchor63"></a>
    "NOA-OLSR" is the protocol specified by this document.
    It is the standard OLSR protocol <a class="info" href="#RFC3626">[3]<span>Clausen, T. and P. Jacquet, Optimized Link State Routing Protocol (OLSR), October 2003.</span></a>
    with the additions and changes specified in this document.
  
</dd>
<dt>Routing Table Contamination Avoidance:</dt>
<dd><a name="anchor64"></a>
    Routing table contamination avoidance is the idea of preserving 
    the routing table from incorrect information
    due to address conflict. This is achieved by using the autoconfiguration
    state (see <a class="info" href="#sec:state">Section 4.5<span>Autoconfiguration State</span></a>).
  
</dd>
<dt>Sequence Number Consistency:</dt>
<dd><a name="anchor65"></a>
    All OLSR messages have a sequence number. One trademark of
    duplicate addresses, is sequence numbers of different messages,
    which could not result from a correct implementation of the OLSR
    protocol (such as decrease in sequence numbers, etc.). 
    The properties of sequence numbers which would result from
    the normal OLSR protocol implementation are termed "Sequence number consistency"
    (see <a class="info" href="#sec:seq-num-consistency">Section 4.4<span>Sequence Number Consistency</span></a>).
  
</dd>
<dt>Standard OLSR:</dt>
<dd><a name="anchor66"></a>
    The terms "standard OLSR protocol" refer to the OLSR protocol specified
   in <a class="info" href="#RFC3626">[3]<span>Clausen, T. and P. Jacquet, Optimized Link State Routing Protocol (OLSR), October 2003.</span></a>. The term "standard" is meant to 
   differentiate with the "non-standard" OLSR protocol proposed in this 
   document 
   (thereafter, "NOA-OLSR"). It is not meant to express its normative
   status within IETF or standardization organizations.
  
</dd>
<dt>TC Generator:</dt>
<dd><a name="anchor67"></a>
    A node which generates TC messages (as originator).
  
</dd>
</dl></blockquote>

<a name="sec:algorithm"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;Autoconfiguration Algorithms</h3>

<a name="rfc.section.4.1"></a><h4><a name="sec:algorithm-overview">4.1</a>&nbsp;Overview</h4>

<p>This section provides a high-level view of the method used for
      autoconfiguration of the node: address selection, duplicate address
      detection based on rules, principles for sequence number consistency,
      use of the autoconfiguration state. The detailed specifications 
      of the method are in <a class="info" href="#sec:specification">Section 5<span>Autoconfiguration Specifications</span></a>.
</p>
<a name="rfc.section.4.2"></a><h4><a name="sec:address-selection">4.2</a>&nbsp;Address Selection</h4>

<p>
When a node is present in a MANET, it can monitor
the protocol message exchanges and collect information regarding 
the addresses in use, the "busy address list".
It can then selects its own address from the pool
of free addresses by avoiding the busy address list.
With OLSR, it is possible for each node to
obtain busy address information through routing control
messages received from other nodes (such information is available
as part of the State Set introduced in <a class="info" href="#sec:state">Section 4.5<span>Autoconfiguration State</span></a>).

</p>
<p>
This document doesn't specify how the addresses should be selected,
apart from the fact any selected address should not be the "busy address list".

</p>
<p>
Some discussions and references about address selection 
(including IPv4 and IPv6 stateless address autoconfiguration) 
can be found, for instance, in the document
<a class="info" href="#I-D.ruffino-manet-autoconf-scenarios">[7]<span>Ruffino, S., Stupar, P. and T. Clausen, Autoconfiguration in a MANET: connectivity scenarios and technical issues, October 2004.</span></a>.

</p>
<a name="rfc.section.4.3"></a><h4><a name="sec:dad">4.3</a>&nbsp;Duplicate Address Detection</h4>

<a name="rfc.section.4.3.1"></a><h4><a name="sec:dad.overview">4.3.1</a>&nbsp;Overview</h4>

<p>Duplicate Address Detection is performed passively, i.e., without
additional control messages. Some various passive DAD techniques were
proposed in <a class="info" href="#ref:pacman">[8]<span>Weniger, K., Passive Duplicate Address Detection in Mobile Ad hoc                   Networks, March 2003.</span></a>, we propose some others.
</p>
<p>In this section, the detection algorithms are detailed. Protocol
specifications are given in a later section. 
</p>
<p>
In a MANET network with nodes running the OLSR, several different
scenarios of
address conflicts may occur. There are classified in three separated
cases:
</p>
<blockquote class="text"><dl>
<dt>Neighbor duplicate address detection:</dt>
<dd>in this case,
two neighbor nodes (in range of each other) have selected the same address.
</dd>
<dt>Two-hop duplicate address detection:</dt>
<dd>in this case, 
two nodes which have selected the same address are two-hop neighbors.
That is, there is another node in the network which is the neighbor 
of those both nodes.
</dd>
<dt>Multihop duplicate address detection:</dt>
<dd>in this case,
the two nodes in conflict are separated by two nodes or more.
</dd>
</dl></blockquote><p>

The three cases of duplicate address are different in that they can
be detected by different methods: for instance the multihop duplicate
address detection requires the use of TC message information, while
the first two cases need not.
</p>
<p>Also, an additional case is added: it's a specific multihop
address conflict case, where the address conflict results in deficiencies
in the MPR selection.

</p>
<a name="rfc.section.4.3.2"></a><h4><a name="sec:dad-rule-notation">4.3.2</a>&nbsp;Notation</h4>

<p>
In the <a class="info" href="#sec:dad">Section 4.3<span>Duplicate Address Detection</span></a>, the following conventions are used to
describe the duplicate address conflict cases for the algorithms:
</p>
<ul class="text">
<li>Capital letters are used to denote different nodes: such as "A", "B", 
     "C", etc...
</li>
<li>Numbers are used to represent different addresses, such as "1", "2",
     "3", etc...
</li>
<li>The following notation is employed to represent the node "A"
 which has the address
    "1": "A{1}". In the event of an address conflict, two nodes may be 
    using the same address, such as 
   "A{1}" and "B{1}" for instance.
</li>
<li>Each DAD rule is associated to a figure which graphically represents
   the topology. An example is given on <a class="info" href="#fig:notation">Figure 1</a>:
  one node "A" with address "1". 
  In the figures which will follow, the nodes which should apply the DAD rule,
  are highlighted by the mark "**", like "A" is,
  on the sample figure.
</li>
</ul>
<a name="fig:notation"></a>
<pre>
+--------------+
| ** Node A{1} |
+--------------+
        </pre>
<table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure 1&nbsp;</b></font><br /></td></tr></table><hr size="1" shade="0">

<a name="rfc.section.4.3.3"></a><h4><a name="sec:dad.1hop">4.3.3</a>&nbsp;Neighbor Duplicate Address Detection</h4>

<p>In the case of "neighbor duplicate address",
two conflicting nodes are neighbors (see <a class="info" href="#fig:R1">Figure 2</a>).
This case is special
since many different non-OLSR methods could be used to detect the conflict:
because the neighbor nodes would receive messages from each other directly,
as they would, for instance,
if they were connected on a Ethernet network.
Thus, most of methods designed for (non-MANET) IP networks, 
such as IPv4 autoconfiguration detection methods
or IPv6 DAD, could be used.
</p>
<p>
Still, due to topology changes such methods could fail, or could not be
available in a node. Hence a rule to detect conflicts at the OLSR protocol 
level in this case is proposed. At mininum,
the two OLSR nodes should at least periodically generate HELLO messages,
hence the following duplicate address detection rule is used:

</p>
<a name="rfc.section.4.3.3.1"></a><h4><a name="rule:R1">4.3.3.1</a>&nbsp;Rule R1</h4>

<p></p>
<blockquote class="text"><dl><a name="anchor68"></a>
<dt>Rule:</dt>
<dd>R1 (see <a class="info" href="#fig:R1">Figure 2</a>)
</dd>
<dt>Context:</dt>
<dd>An HELLO message is received by a node A{1}.
</dd>
<dt>Check:</dt>
<dd>Is the address {1}, the address of the originator node 
                      ?
</dd>
<dt>Action:</dt>
<dd>If it is the case, this node is in conflict and
must select a new address.
</dd>
<dt>Rationale:</dt>
<dd>A node doesn't receive its own HELLO messages
(they are not forwarded), hence the occurence of such an event means
that a node with the same address has sent an HELLO.
</dd>
</dl></blockquote>
<a name="fig:R1"></a>
<pre>
+--------------+       +--------------+
| ** Node A{1} | &lt;---&gt; | ** Node B{1} |
+--------------+       +--------------+
        </pre>
<table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure 2&nbsp;</b></font><br /></td></tr></table><hr size="1" shade="0">

<p>As mentioned, this rule can be completed by other duplicate address
detection
mechanisms, not specified in this document, as they are beyond its scope.

</p>
<p>The detection R1 can be performed using HELLO messages
(in any autoconfiguration state, including HELLO_STATE). 
</p>
<a name="rfc.section.4.3.4"></a><h4><a name="sec:dad.2hop">4.3.4</a>&nbsp;Two-hop duplicate address detection</h4>

<p>
In this case, the two conflicting nodes are two-hop neighbors, that is:
they are not neighbor, but they have a common neighbor (see 
<a class="info" href="#fig:R2">Figure 3</a>).
The rule proposed here relies on the fact that a common neighbor exists,
and will receive the HELLO from both nodes. The detection proceeds in three
steps: the common neighbor detects the conflict using those HELLOs,
then it advertises the conflict in some message(s)
(rule R2), and finally, the conflicting
nodes change their address upon receiving this conflict advertisement 
(rule R3).

</p>
<a name="rfc.section.4.3.4.1"></a><h4><a name="rule:R2">4.3.4.1</a>&nbsp;Rule R2</h4>

<p></p>
<blockquote class="text"><dl><a name="anchor69"></a>
<dt>Rule:</dt>
<dd>R2 (see <a class="info" href="#fig:R2">Figure 3</a>)
</dd>
<dt>Context:</dt>
<dd>In node B{2}: an HELLO message from address {1} was 
received previously, and another HELLO from address {1} 
is just received by B{2}.
</dd>
<dt>Check:</dt>
<dd>Are the sequence numbers of the HELLOs inconsistent
(as defined in <a class="info" href="#sec:seq-num-consistency">Section 4.4<span>Sequence Number Consistency</span></a>)?

</dd>
<dt>Action:</dt>
<dd>If it is the case, there are two or more neighbors
using the same address {1}. B{2} will advertise that the address {1}
is conflicting in its HELLO messages.
</dd>
<dt>Rationale:</dt>
<dd>If two neighbors of one node have conflicting
addresses, the HELLO sequence numbers will be inconsistent.

</dd>
</dl></blockquote>
<a name="fig:R2"></a>
<pre>
+--------------+       +--------------+       +--------------+
|  Node A{1}   | &lt;---&gt; | ** Node B{2} | &lt;---&gt; |  Node C{1}   |
+--------------+       +--------------+       +--------------+
        </pre>
<table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure 3&nbsp;</b></font><br /></td></tr></table><hr size="1" shade="0">

<a name="rfc.section.4.3.4.2"></a><h4><a name="rule:R3">4.3.4.2</a>&nbsp;Rule R3</h4>

<p></p>
<blockquote class="text"><dl><a name="anchor70"></a>
<dt>Rule:</dt>
<dd>R3 (see <a class="info" href="#fig:R3">Figure 4</a>)
</dd>
<dt>Context:</dt>
<dd>In node A{1} (and node C{1}): a neighbor B{2}
is advertising that conflict exists with the address {1}.
</dd>
<dt>Check:</dt>
<dd>-
</dd>
<dt>Action:</dt>
<dd>If it is the case, A{1} is a conflicting node and 
must select a new address.
</dd>
</dl></blockquote>
<a name="fig:R3"></a>
<pre>
+--------------+       +--------------+       +--------------+
| ** Node A{1} | &lt;---&gt; |  Node B{2}   | &lt;---&gt; | ** Node C{1} |
+--------------+       +--------------+       +--------------+
        </pre>
<table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure 4&nbsp;</b></font><br /></td></tr></table><hr size="1" shade="0">

<p>
The detections R2 and R3 can be performed using HELLO messages
(in any autoconfiguration state, including HELLO_STATE).
</p>
<a name="rfc.section.4.3.5"></a><h4><a name="sec:dad.nhop">4.3.5</a>&nbsp;Multihop duplicate address detection</h4>

<p>
In this section, DAD rules are proposed to handle the case where the distance
between conflicting nodes is three hops or more. In this case, in general,
it cannot be assumed that a single node has enough information
to detect the conflict using exclusively the HELLO messages.
Hence, the logical choice is here to use information inside TC messages.
However the duplicate address detection is complicated by the optimizations
of the OLSR routing protocol: first, not all nodes originate TC messages ;
second, TC messages might include only a subset of neighbors ; third,
OLSR messages may be split and as a consequence, an individual TC message
from one node might not include all the topology information that the node
should periodically refresh. Finally, the MPR selection algorithm
can be affected by duplicate addresses, and prevent proper operation
of the MPR flooding mechanism, hence prevent proper propagation of the TCs
used by DAD. 

</p>
<p>
The DAD rules that are specified in the case of multihop DAD are
classified depending on the status of the conflicting nodes with respect
to TC generation: 
a node which generates TC messages (when it is a multipoint relay of
some node) is called a TC generator. Three cases are possible and are
handled:
</p>
<ul class="text">
<li>Both conflicting nodes are TC generators.
</li>
<li>One of the conflicting nodes is a TC generator, and the other is not.
</li>
<li>None of the conflicting nodes is TC generator.
</li>
</ul><p>
In each of the three cases, the DAD rules allow detection both on the
conflicting
nodes (which would then change address) and on intermediary nodes 
(which would then avoid routing table contamination).

Finally some DAD rules are used for preventing the following case:
</p>
<ul class="text">
<li>Conflicting nodes are impeding MPR selection.
</li>
</ul><p> 
The following four sections handle individually each case.

</p>
<a name="rfc.section.4.3.5.1"></a><h4><a name="sec:dad.nhop.tc-tc">4.3.5.1</a>&nbsp;Multihop DAD with two TC generators</h4>

<p>
In this case, the two nodes in conflict are both TC generators.
Then each of them would ultimately receive one TC with its own
originator address, but which it did not generate (for
it was generated by the other node). The intermediate nodes
would also detect conflict by noticing discrepancy in the sequence
numbers or discrepancy in the content of the TC messages with same sequence
number.

</p>
<p>The first rule applies to conflicting nodes (<a class="info" href="#rule:R4">R4<span>Rule R4</span></a>), the
second applies to other nodes in the network (<a class="info" href="#rule:R5">R5<span>Rule R5</span></a>).

</p>
<a name="rfc.section.4.3.5.1.1"></a><h4><a name="rule:R4">4.3.5.1.1</a>&nbsp;Rule R4</h4>

<p></p>
<blockquote class="text"><dl><a name="anchor71"></a>
<dt>Rule:</dt>
<dd>R4 (see <a class="info" href="#fig:R4">Figure 5</a>)
</dd>
<dt>Context:</dt>
<dd>In node A{1} (or node C{1}): a TC with originator
address {1} has been received. 
A{1} keeps track of the TC messages that it has sent.
</dd>
<dt>Check:</dt>
<dd>Verify whether A has actually sent that TC: the
message sequence number should be the same as one message that A has sent
in the past, and then the content should be the same.
</dd>
<dt>Action:</dt>
<dd>If it is not the case, A{1} is a conflicting node and
must select a new address.
</dd>
</dl></blockquote>
<a name="fig:R4"></a>
<pre>
+--------------+           +--------------+           +--------------+
| ** Node A{1} | &lt;- ... -&gt; |  Node B{2}   | &lt;- ... -&gt; | ** Node C{1} |
| TC generator |           |              |           | TC generator |
+--------------+           +--------------+           +--------------+
        </pre>
<table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure 5&nbsp;</b></font><br /></td></tr></table><hr size="1" shade="0">

<a name="rfc.section.4.3.5.1.2"></a><h4><a name="rule:R5">4.3.5.1.2</a>&nbsp;Rule R5</h4>

<p></p>
<blockquote class="text"><dl><a name="anchor72"></a>
<dt>Rule:</dt>
<dd>R5 (see <a class="info" href="#fig:R5">Figure 6</a>)
</dd>
<dt>Context:</dt>
<dd>In node B{2}: an TC message with originator 
address {1} was received previously by the node, and another
TC with originator address {1} is just received by B{2}
</dd>
<dt>Check:</dt>
<dd>Are the sequence numbers of the TC messages consistent
(as defined in <a class="info" href="#sec:seq-num-consistency">Section 4.4<span>Sequence Number Consistency</span></a>)? Is the content
of the TC identical to the one(s) received before?
</dd>
<dt>Action:</dt>
<dd>If it not is the case, there are two or more nodes
using the same address {1}: then the TC should be forwarded (if it is
has not already been), but the content of the TC will be ignored
and not processed 
</dd>
<dt>Rationale:</dt>
<dd>This detects a conflict between TC generators.
If the conflicting nodes are sending TC messages with same sequence number,
standard MPR flooding might not allow the TC messages to reach the other node.
Hence in case of conflict, the TC should be forwarded by default. Also,
because a conflict has been detected, the received TC is guaranted to
hold information which is inconsistent with the information already
processed because it was issued by a different node ; and hence, 
the content of TC message should be ignored.
 
</dd>
</dl></blockquote>
<a name="fig:R5"></a>
<pre>
+--------------+           +--------------+           +--------------+
|  Node A{1}   | &lt;- ... -&gt; | ** Node B{2} | &lt;- ... -&gt; |  Node C{1}   |
| TC generator |           |              |           | TC generator |
+--------------+           +--------------+           +--------------+
        </pre>
<table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure 6&nbsp;</b></font><br /></td></tr></table><hr size="1" shade="0">

<a name="rfc.section.4.3.5.2"></a><h4><a name="sec:dad.nhop.notc-notc">4.3.5.2</a>&nbsp;Multihop DAD with two non-generators</h4>

<p>
In this section, DAD rules are given for 
the case where none of the conflicting nodes is a TC generator.
In such a configuration, the conflict is detected by means of 
by using the TC messages of the multi-point relays of the nodes. As one
conflicting node selects some MPR, these MPR will send TC messages 
indicating this selection: when one of the TC messages
reaches the other conflicting
node, this node will detect inconsistency by discovering that
it did not, actually, select the TC originator as MPR.

</p>
<p>
The DAD for intermediate nodes is, however more complex, because they cannot
rely on sequence numbers as in previous section 
<a class="info" href="#sec:dad.nhop.tc-tc">Section 4.3.5.1<span>Multihop DAD with two TC generators</span></a>, nor they can rely on knowledge of
the actual MPR selection of every node like the nodes in conflict.
Hence to detect occurences of such conflicts, another mechanism is used: it is
based on the concept of familiar nodes. A node (an IP address) is familiar 
for another node, when the last one has had knowledge 
of existence of the first one for sufficiently long
(see <a class="info" href="#sec:familiarity">Section 4.6<span>Node Familiarity</span></a>).

</p>
<p>
The hypothesis made now is that most conflicts occur because of network
merges. In such an address conflict, now, let's assume a node from
one network is now sending TC messages including 
the address of one node (in conflict with this network)
from another, newly merged, network. For instance, let us consider
<a class="info" href="#fig:R6">Figure 7</a>, and let us assume that A{1}, C{2}, and E{4} were
previously part of one network, while B{1} and D{3} (one of its MPRs)
were part of another.
It is reasonable to assume
that D{3} will become the neighbor of few nodes of the first network, which
it will advertise. Hence, most likely, the TC messages of D{3}, which advertise
the conflicting node B{1}, also include mostly addresses of nodes from the
merged network, which would be unfamiliar nodes for A{1}.
Thence the DAD rule:
ignore the information relative to familiar nodes, when it is inside
TC messages from unfamiliar nodes,
which also include too many unfamiliar nodes.

</p>
<p>
Another rule is added for neighbors of the node A{1}, such as C{2}:
because they have knowledge of the neighborhood of A{1}, they are able
to directly check if D{3} is a neighbor of A{1}.

</p>
<a name="rfc.section.4.3.5.2.1"></a><h4><a name="rule:R6">4.3.5.2.1</a>&nbsp;Rule R6</h4>

<p></p>
<blockquote class="text"><dl><a name="anchor73"></a>
<dt>Rule:</dt>
<dd>R6 (see <a class="info" href="#fig:R6">Figure 7</a>)
</dd>
<dt>Context:</dt>
<dd>In node A{1}: a TC message with originator
address {3} has been received.
</dd>
<dt>Check:</dt>
<dd>If this TC includes the address {1} of A, A checks
whether it had recently selected {3} as MPR.
</dd>
<dt>Action:</dt>
<dd>If it is not the case, A{1} is a conflicting node and 
must select a new address.
</dd>
<dt>Rationale:</dt>
<dd>If A{1} has not selected {3} as MPR, then another
node with address {1} must have done so, hence there is an 
address conflict.
</dd>
</dl></blockquote>
<a name="fig:R6"></a>
<pre>
+--------------+                                      +--------------+
| ** Node A{1} |                                      | ** Node B{1} |
|  (non-MPR)   |                                      |  (non-MPR)   |
+--------------+                                      +--------------+
      ^                                                       ^
      |                                                       |
      V                                                       V
+--------------+           +--------------+           +--------------+
|  Node C{2}   | &lt;- ... -&gt; |  Node E{4}   | &lt;- ... -&gt; |  Node D{3}   |
| TC generator |           |              |           | TC generator |
+--------------+           +--------------+           +--------------+
</pre>
<table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure 7&nbsp;</b></font><br /></td></tr></table><hr size="1" shade="0">

<a name="rfc.section.4.3.5.2.2"></a><h4><a name="rule:R7">4.3.5.2.2</a>&nbsp;Rule R7</h4>

<p></p>
<blockquote class="text"><dl><a name="anchor74"></a>
<dt>Rule:</dt>
<dd>R7 (see <a class="info" href="#fig:R7">Figure 8</a>)
</dd>
<dt>Context:</dt>
<dd>In node E{4}: a TC message
from originator {2}, which is familiar for E,  had been received.
It included the familiar (for E) address {1}.
Another TC, from originator {3}, an unfamiliar node for E, is including 
the same familiar address {1}.
</dd>
<dt>Check:</dt>
<dd>In this TC, check how many addresses are from
familiar nodes. If too little addresses are familiar, then the TC
is assumed to include an address {1} which is conflicting.
</dd>
<dt>Action:</dt>
<dd>If conflict is assumed, then the information of
the TC of {3} about address {1} is ignored (the previous one from {3}
will still be used), but all other content is kept.
</dd>
<dt>Rationale:</dt>
<dd>This is an heuristic for detecting conflict. Note
that in any case, a route to {1} can still be computed using the TC
message from {2}.
Note also that after some time, {3} and all the nodes advertised by {3} will
be familiar to E, ensuring that this rule will no longer apply.
</dd>
</dl></blockquote>
<a name="fig:R7"></a>
<pre>
+--------------+                                      +--------------+
|  Node A{1}   |                                      |  Node B{1}   |
|  (non-MPR)   |                                      |  (non-MPR)   |
+--------------+                                      +--------------+
      ^                                                       ^
      |                                                       |
      V                                                       V
+--------------+           +--------------+           +--------------+
|  Node C{2}   | &lt;- ... -&gt; | ** Node E{4} | &lt;- ... -&gt; |  Node D{3}   |
| TC generator |           |              |           | TC generator |
+--------------+           +--------------+           +--------------+
</pre>
<table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure 8&nbsp;</b></font><br /></td></tr></table><hr size="1" shade="0">

<a name="rfc.section.4.3.5.2.3"></a><h4><a name="rule:R8">4.3.5.2.3</a>&nbsp;Rule R8</h4>

<p></p>
<blockquote class="text"><dl><a name="anchor75"></a>
<dt>Rule:</dt>
<dd>R8 (see <a class="info" href="#fig:R8">Figure 9</a>)
</dd>
<dt>Context:</dt>
<dd>In node C{2}: a HELLO message
from node {1} was previously received, and a TC message from node {3}
is now received.
</dd>
<dt>Check:</dt>
<dd>If the TC message from {3} includes {1} as
MPR selector, the HELLO from {1} should also have included {3}
as symmetrical neighbor (actually more: as MPR)
</dd>
<dt>Action:</dt>
<dd>If this not the case, then a conflict is assumed
for address {1}. Then the information of
the TC message of {3} about address {1} is ignored (the previous one from {3}
will still be used), but all other content is kept.
</dd>
<dt>Rationale:</dt>
<dd>This is another heuristic for detecting
conflict, for every node which is neighbor of the conflicting nodes.

</dd>
</dl></blockquote>
<a name="fig:R8"></a>
<pre>
+--------------+                                      +--------------+
|  Node A{1}   |                                      |  Node B{1}   |
|  (non-MPR)   |                                      |  (non-MPR)   |
+--------------+                                      +--------------+
      ^                                                       ^
      |                                                       |
      V                                                       V
+--------------+           +--------------+           +--------------+
| ** Node C{2} | &lt;- ... -&gt; |   Node E{4}  | &lt;- ... -&gt; |  Node D{3}   |
| A's neighbor |           |              |           | TC generator |
+--------------+           +--------------+           +--------------+
</pre>
<table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure 9&nbsp;</b></font><br /></td></tr></table><hr size="1" shade="0">

<a name="rfc.section.4.3.5.3"></a><h4><a name="anchor2">4.3.5.3</a>&nbsp;Multihop DAD with one TC Generator and one Non-Generator</h4>

<p>
In case one of the nodes in conflict is a TC generator while the other
one is not, the conflict can be detected by as previously. The TC generator
can conduct duplicate address detection by checking the TC messages of the MPR
of the other node using DAD rule <a class="info" href="#rule:R6">R6<span>Rule R6</span></a>. The conflicting node that
does not generate TC messages, can detect conflict with DAD rule <a class="info" href="#rule:R4">R4<span>Rule R4</span></a>.

</p>
<p>
However for intermediary nodes, a new case is possible. We still assume
most conflicts occur because of network merges. Then it is possible that
for one network, one conflicting node is a TC generator in the other network,
while the other one is not.
Using the same logic as previously,
the TC message of that conflicting node would include many 
unfamiliar nodes, hence one DAD rule is to reject such TC.

</p>
<a name="rfc.section.4.3.5.3.1"></a><h4><a name="rule:R9">4.3.5.3.1</a>&nbsp;Rule R9</h4>

<p></p>
<blockquote class="text"><dl><a name="anchor76"></a>
<dt>Rule:</dt>
<dd>R9 (see <a class="info" href="#fig:R9">Figure 10</a>)
</dd>
<dt>Context:</dt>
<dd>In node E{4}: a TC 
from originator familiar node {2} (familiar for E) had been received
and it included the (familiar for E) address {1}.
Another TC message, from originator {1}, is received.
</dd>
<dt>Check:</dt>
<dd>In this TC, check how many addresses are from
familiar nodes. If too little addresses are familiar, then the TC
is assumed to be from an unfamiliar node from a merged network.
</dd>
<dt>Action:</dt>
<dd>If conflict is assumed, then the information of
the TC is ignored (the previous one from {2}
will still be used).
</dd>
<dt>Rationale:</dt>
<dd>This is an heuristic for detecting conflict. Note
that in any case, a route to {1} can still be computed using {2}
and note that in absence of conflict, anyway,
after some time, all the nodes advertised by {1} will
be familiar to E, ensuring that this rule will no longer apply.
</dd>
</dl></blockquote>
<a name="fig:R9"></a>
<pre>
+--------------+
|  Node A{1}   |
|  (non-MPR)   |
+--------------+
      ^         
      |         
      V         
+--------------+           +--------------+           +--------------+
|  Node C{2}   | &lt;- ... -&gt; | ** Node E{4} | &lt;- ... -&gt; |  Node B{1}   |
| TC generator |           |              |           | TC generator |
+--------------+           +--------------+           +--------------+
</pre>
<table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure 10&nbsp;</b></font><br /></td></tr></table><hr size="1" shade="0">

<p>
Additionally, still in the case of network merge, the nodes that are on the
border of the network merge can actually use some heuristics for
detecting conflicts. Indeed, if a node, is from another (merging) network, it
is likely to have many unfamiliar nodes as neighbors. And those
unfamiliar nodes will be present in the Hello messages of the node.
Hence when a node detects that one of its neighbors has too many
other neighbors that are unfamiliar, it can suspect the neighbor
is from another network. In case the node is a TC generator, it will
then mark the address of the node as unfamiliar.

</p>
<a name="rfc.section.4.3.5.3.2"></a><h4><a name="rule:R10">4.3.5.3.2</a>&nbsp;Rule R10</h4>

<p></p>
<blockquote class="text"><dl><a name="anchor77"></a>
<dt>Rule:</dt>
<dd>R10 (see <a class="info" href="#fig:R10">Figure 11</a>)
</dd>
<dt>Context:</dt>
<dd>
 In node C{3}: a TC message is being generated,
and it includes neighbor {1}.
</dd>
<dt>Check:</dt>
<dd>\myitem{Check:} In the neighborhood of X{1} (which is
obtained from the Hello messages, in the two-hop tuple set) 
check how many addresses are from familiar
nodes. If too little addresses are familiar, then the neighbor is assumed to
be an node from a merged network.
</dd>
<dt>Action:</dt>
<dd> If too little address are familiar, the address {1}
is advertised as being "with too many unfamiliar neighbors".
</dd>
<dt>Rationale:</dt>
<dd>
This is an heuristic to avoid routing table contamination.
Note that the address {1} is still advertised 
and can be used by node A{1} to detect the conflict.
</dd>
</dl></blockquote>
<a name="fig:R10"></a>
<pre>
                                                      +--------------+
                                                      |  Node X{1}   |
                                                      |              |
                                                      +--------------+
                                                             ^         
                                                             |         
                                                             V         
+--------------+           +--------------+           +--------------+
|  Node A{1}   | &lt;- ... -&gt; |  Node B{2}   | &lt;- ... -&gt; | ** Node C{3} |
|              |           |              |           | TC generator |
+--------------+           +--------------+           +--------------+
</pre>
<table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure 11&nbsp;</b></font><br /></td></tr></table><hr size="1" shade="0">

<p>
The following rule uses the information transmitted by the previous one:
</p>
<a name="rfc.section.4.3.5.3.3"></a><h4><a name="rule:R11">4.3.5.3.3</a>&nbsp;Rule R11</h4>

<p></p>
<blockquote class="text"><dl><a name="anchor78"></a>
<dt>Rule:</dt>
<dd>R11 (see <a class="info" href="#fig:R11">Figure 12</a>)
</dd>
<dt>Context:</dt>
<dd> In node B{2}: a TC message has been received from
originator {3} and it includes neighbor {1} marked as
``with too many unfamiliar neighbors'', by rule R10 in node {3}.
</dd>
<dt>Check:</dt>
<dd> - 
</dd>
<dt>Action:</dt>
<dd> The address {1} should be ignored in the
processing of the TC message. But the other addresses may
still be used, and the TC should still be forwarded.%with std MPR flooding.
</dd>
<dt>Rationale:</dt>
<dd> This is an heuristic to avoid routing table
contamination,
using information from rule R10. 
</dd>
</dl></blockquote>
<a name="fig:R11"></a>
<pre>
                                                      +--------------+
                                                      |  Node X{1}   |
                                                      |              |
                                                      +--------------+
                                                             ^         
                                                             |         
                                                             V         
+--------------+           +--------------+           +--------------+
|  Node A{1}   | &lt;- ... -&gt; | ** Node B{2} | &lt;- ... -&gt; |  Node C{3}   |
|              |           |              |           | TC generator |
+--------------+           +--------------+           +--------------+
</pre>
<table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure 12&nbsp;</b></font><br /></td></tr></table><hr size="1" shade="0">

<a name="rfc.section.4.3.5.4"></a><h4><a name="anchor3">4.3.5.4</a>&nbsp;Three-hop DAD, Specific Case</h4>

<p>
It has been noted that in some cases the MPR selection process can fail
because of duplicate addresses (see <a class="info" href="#ref:pacman">[8]<span>Weniger, K., Passive Duplicate Address Detection in Mobile Ad hoc                   Networks, March 2003.</span></a>).
As a result, the MPR flooding mechanism
may fail to deliver a message to the entire network, and then the previous
DAD rules may fail to detect the duplicate address detection.
This situation is illustrated on <a class="info" href="#fig:R12">Figure 13</a>.
A specific rule can be devised to prevent this situation and allow
proper MPR selection: on the figure, the node B{2} is able to
detect that there is an inconsistency in the neighborhood advertised
by {1} and {3}, which may possibly arise from {1} being a duplicate address.
In this case, the MPR selection of B would be deficient: so
B can still preventively select {3} as MPR by itself. That way,
the messages from A{1}
going through B will reach D{1} (triggering one of the previous DAD rules).

</p>
<a name="rfc.section.4.3.5.4.1"></a><h4><a name="rule:R12">4.3.5.4.1</a>&nbsp;Rule R12</h4>

<p></p>
<blockquote class="text"><dl><a name="anchor79"></a>
<dt>Rule:</dt>
<dd>R12 (see <a class="info" href="#fig:R12">Figure 13</a>)
</dd>
<dt>Context:</dt>
<dd>In node B{2}: a HELLO
from node {1} had been received, and now an HELLO from node {3}
is received.
</dd>
<dt>Check:</dt>
<dd>If the HELLO from {3} includes {1} as
symmetrical neighbor, the HELLO from {1} should also have included {3}
as symmetrical neighbor.
</dd>
<dt>Action:</dt>
<dd>If it is not the case, there is an inconsistency 
and the node B should select {3} as MPR.
</dd>
<dt>Rationale:</dt>
<dd>Such inconsistencies should never happen
in a static network, unless there is a conflict. Note also that
due to topology changes, they may do so even if there is no conflict. 
In that case, note that the only
penalty is an temporary increase of the number of MPR selected. 
It is still an excellent
heuristic that will solve the MPR selection problem when the network
is static.
</dd>
</dl></blockquote>
<a name="fig:R12"></a>
<pre>
+--------------+       +--------------+
|  Node A{1}   |       |  Node D{1}   |
+--------------+       +--------------+
      ^                        ^
      |                        |
      V                        V
+--------------+       +--------------+
| ** Node B{2} | &lt;---&gt; |  Node C{3}   |
+--------------+       +--------------+
</pre>
<table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure 13&nbsp;</b></font><br /></td></tr></table><hr size="1" shade="0">

<a name="rfc.section.4.4"></a><h4><a name="sec:seq-num-consistency">4.4</a>&nbsp;Sequence Number Consistency</h4>

<p>
In <a class="info" href="#ref:pacman">[8]<span>Weniger, K., Passive Duplicate Address Detection in Mobile Ad hoc                   Networks, March 2003.</span></a>, the use of sequence numbers to verify
consistency has been used in some general cases. Here, sequence number
consistency is checked for the OLSR protocol, and consist really of
two cases: HELLO sequence number consistency, and TC sequence
number consistency.

</p>
<a name="rfc.section.4.4.1"></a><h4><a name="anchor4">4.4.1</a>&nbsp;Minimum Wrap-Around Limit</h4>

<p>
In the <a class="info" href="#RFC3626">OLSR protocol<span>Clausen, T. and P. Jacquet, Optimized Link State Routing Protocol (OLSR), October 2003.</span></a>[3], it is implicitly
 assumed that the sequence number of one node will
wrap-around within an interval of time greater than DUP_HOLD_TIME.
Hence this value is a good reference for the minimum 
expected interval before a wrap-round the sequence number of any node
in the network, denoted MIN_WRAP_AROUND_INTERVAL. 
</p>
<a name="rfc.section.4.4.2"></a><h4><a name="sec:hello-consistency">4.4.2</a>&nbsp;HELLO Sequence Number Consistency</h4>

<p>
In case of HELLO messages, 
it is assumed that they would be received in the same order as they
are transmitted (because they are not forwarded). In this case,
a node observing the HELLO messages from a neighbor will see that
their sequence numbers are permanently increasing.
Now if there are two neighbors B and C of one node A,
the node A will receive alternatively messages from B and C,
because each
is transmitting indefinitly. Hence A must receive a sequence of packets
from B, then some packets from C, then some packets from B, and so on.
Let's assume that ultimately a sufficiently long sequence is received 
without packet loss, and which then will be in this order:
</p>
<ul class="text">
<li>one packet B1 from B (possibly the last one of a sequence of packets 
   from B)
</li>
<li>some packets from C
</li>
<li>one packet B2 from B (possibly the first one of a sequence of packets
  from B)
</li>
</ul><p>
Now because there was no packet loss, the sequence number of the packet B2
is the sequence number of the packet B1 plus 1.
As a result, considering the sequence number of any packet from C:
</p>
<ul class="text">
<li>If it is greater than the sequence number of B1, then: the
   sequence number of the packet B2 will be less or equal 
   to the sequence number of the packets from C.
</li>
<li>Otherwise it is equal to or less than the sequence number of B1.
</li>
</ul><p>
In both events, A observes a decrease or a repetition of the sequence numbers
of B.
</p>
<p>Hence, for HELLO messages, it is sufficient to check if the HELLO
received from
one address is equal to, or less than, the sequence number of the previous
HELLO received from this address.
</p>
<p>However, because a node may not be constantly
a neighbor (and hence, quite naturally, a large number of successive HELLO
messages may not be received), this condition should be checked 
only when there was no wrap-around, 
hence when the interval between the previous HELLO received
and the last HELLO received from the same address is less 
than MIN_WRAP_AROUND_INTERVAL.

</p>
<a name="rfc.section.4.4.3"></a><h4><a name="sec:tc-consistency">4.4.3</a>&nbsp;TC Sequence Number Consistency</h4>

<p>Because TC messages are forwarded with the MPR flooding mechanism,
first, the same message may be received several time, secondly,
the packet order can be changed, especially with the use of jitter.
Hence the algorithm used previously for <a class="info" href="#sec:hello-consistency">checking consistency of HELLO messages<span>HELLO Sequence Number Consistency</span></a> can not be used as is.

</p>
<p>
Hence the following principles are used:
</p>
<ul class="text">
<li>The sequence number and the receving time of the last TC message for each
originator is recorded.
</li>
<li>Each time a TC message is received from a given originator,
with a given sequence number,
 the node checks whether if a TC message with similar
identification
already was received. If it was,
it checks that the previous content is identical to the current content.
</li>
<li>If the sequence number difference (in absolute value) 
between the new TC and previous TC from the same originator is above a 
given threshold MAX_TC_DIFF_SEQ_NUM, then duplicate address can be suspected. 
Such an event is possible, for instance if another node sends
many non-TC messages or cease to be TC generator for some time ; thus
an additional check is performed on the message
rate: an approximation of the message rate is computed as
the "sequence number difference divided by the reception time difference".
If this message rate is greater than a threshold MAX_MESSAGE_RATE,
then the TC Sequence Number are deemed inconsistent.

</li>
</ul><p>
If precise adjustement is desired for
the values of MAX_TC_DIFF_SEQ_NUM, and MAX_MESSAGE_RATE (peak rate), it can
be observed that one of the worst case occurs when two nodes are in conflict, 
and one is using the same sequence numbers of the other with a delay
a little greater than DUP_HOLD_TIME.


</p>
<a name="rfc.section.4.5"></a><h4><a name="sec:state">4.5</a>&nbsp;Autoconfiguration State</h4>

<a name="rfc.section.4.5.1"></a><h4><a name="sec:state.overview">4.5.1</a>&nbsp;Introduction</h4>

<p> Each node has an "autoconfiguration state". This state is an
indicator of how long the node has been in the network. The central
idea, is that each time a node selects a new address, it should enter
the network gradually, running a restrained version of the OLSR
protocol.  By this way, that the node can detect which addresses are
being used, checking for duplicates of its own address, 
while avoiding to disrupt the
routing tables of the other nodes, in the event that its address is
actually found to be in conflict.

</p>
<a name="rfc.section.4.5.2"></a><h4><a name="sec:state.functionning">4.5.2</a>&nbsp;Functionning</h4>

<p>
There are exactly 3 autoconfiguration states, in each of which the behavior
of the node is:
</p>
<blockquote class="text"><dl>
<dt>HELLO_STATE:</dt>
<dd>
When a node newly assigns its own address, it enters
the HELLO_STATE, where it generates HELLO messages, but not topology
control (TC) messages. It does not participate in MPR selection
nor MPR flooding, and does not
participate in data packet forwarding either. It doesn't fill the 
topology set nor the routing table. When it detects that it has an address
conflict with other nodes based on received hello messages (rules R1 to R3,
and rule R12),
it re-selects a new address based on the busy address list. When a
pre-determined time has elapsed, in this state, without detecting address
conflict, the node enters the topology state.

</dd>
<dt>TOPOLOGY_STATE:</dt>
<dd>
In this state, a node generates HELLO messages, but not TC messages.
It processes TC messages, and performs MPR selection,
but cannot be MPR itself and hence, does not forward TC messages. 
It fills the network
topology set but not the routing table, and does not participate in data
packet forwarding. When it detects that it has an address conflict with
another node (based rules R1 to R12 applied to received messages),
it re-selects a new address (using the recommendations
of <a class="info" href="#sec:address-selection">Section 4.2<span>Address Selection</span></a>) and returns to the HELLO_STATE. 
When a pre-determined time elapses in the TOPOLOGY_STATE
without detecting address conflict, the node enters the NORMAL_STATE.

</dd>
<dt>NORMAL_STATE:</dt>
<dd>
In this state, the node is running the "normal" OLSR protocol, completed with
the  algorithms specified in this document
, and without message processing/generation
restrictions associated to the state. More precisely,
the node generates both HELLO messages and TC messages as usual. It
processes TC messages generated by other nodes and forwards them as usual
based on MPR flooding. It fills the topology set,
calculates routing tables and participates in data
forwarding. Only nodes in the NORMAL_STATE are selected as the intermediary
nodes (forwarders) in the routing table calculation. 
When the node detects that it has an address
conflict with other nodes (according to one of the rules R1 to R12),
it re-selects a new address and enters
the HELLO_STATE.

</dd>
</dl></blockquote>
<p><p>
  The behavior in each state is summarized in the following table:
</p><table class="data" align="center" border="1" cellpadding="2" cellspacing="2">
<tr>
<th align="center" width="25%">State</th>
<th align="center" width="25%">HELLO_ STATE</th>
<th align="center" width="25%">TOPOLOGY_ STATE</th>
<th align="center" width="25%">NORMAL_ STATE</th>
</tr>
<tr>
<td align="center">Selectable as MPR</td>
<td align="center">no</td>
<td align="center">no</td>
<td align="center">yes</td>
</tr>
<tr>
<td align="center">MPR selection</td>
<td align="center">no</td>
<td align="center">yes</td>
<td align="center">yes</td>
</tr>
<tr>
<td align="center">TC message forwarding</td>
<td align="center">no</td>
<td align="center">no</td>
<td align="center">yes</td>
</tr>
<tr>
<td align="center">TC message processing (MPR flooding)</td>
<td align="center">no</td>
<td align="center">yes</td>
<td align="center">yes</td>
</tr>
<tr>
<td align="center">TC message generation</td>
<td align="center">no</td>
<td align="center">no</td>
<td align="center">yes</td>
</tr>
<tr>
<td align="center">Routing table (and forwarding)</td>
<td align="center">no</td>
<td align="center">no</td>
<td align="center">yes</td>
</tr>
<tr>
<td align="center">DAD rules</td>
<td align="center">R1, R2, R3, and R12</td>
<td align="center">R1 to R12</td>
<td align="center">R1 to R12</td>
</tr>
<tr>
<td align="center">State duration (if no address change)</td>
<td align="center">HELLO_ STATE_ DURATION</td>
<td align="center">TOPOLOGY_ STATE_ DURATION</td>
<td align="center">forever</td>
</tr>
</table>


<a name="rfc.section.4.6"></a><h4><a name="sec:familiarity">4.6</a>&nbsp;Node Familiarity</h4>

<p>
The concept of "node familiarity" is introduced for use of some heuristics
in DAD rules.  The definition is the following: a node (or more
precisely, an IP address) is "familiar" for another node, when the last
one has had knowledge of existence of the first one for sufficiently
long. An node which is not familiar is "unfamiliar".

</p>
<p>
In NOA-OLSR, a node (more precisely, an address) considered familiar when
the time elapsed since the first time that its address has appeared in 
any OLSR message,
is greater than a fixed
time interval NODE_FAMILIAR_TIME (see <a class="info" href="#sec:constant">Section 6<span>Proposed Values for Constants</span></a>).

</p>
<a name="sec:specification"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;Autoconfiguration Specifications</h3>

<a name="rfc.section.5.1"></a><h4><a name="sec:specification-overview">5.1</a>&nbsp;Overview</h4>

<p>
This section provide a low-level view of the changes and additions to
the standard OLSR, necessary to implement NOA-OLSR performing
duplicate address detection. The high-level description of the 
 method, including algorithms, is in <a class="info" href="#sec:algorithm">Section 4<span>Autoconfiguration Algorithms</span></a>.

</p>
<a name="rfc.section.5.2"></a><h4><a name="sec:repository">5.2</a>&nbsp;Information Repository</h4>

<p>Though the exchange of OLSR control messages, each node accumulates
information about the network. This information is stored according
to the descriptions in section 4 of the OLSR specification <a class="info" href="#RFC3626">[3]<span>Clausen, T. and P. Jacquet, Optimized Link State Routing Protocol (OLSR), October 2003.</span></a>, modified accordingly to
the changes proposed to this section.
</p>
<a name="rfc.section.5.2.1"></a><h4><a name="anchor5">5.2.1</a>&nbsp;Autoconfiguration State</h4>

<p>
Each node has one "autoconfiguration state" (see <a class="info" href="#sec:state">Section 4.5<span>Autoconfiguration State</span></a>),
which is one of HELLO_STATE, TOPOLOGY_STATE and NORMAL_STATE.

</p>
<a name="rfc.section.5.2.2"></a><h4><a name="anchor6">5.2.2</a>&nbsp;State Information Base</h4>

<p>
The State Information Base is the State Set: a set of type which 
hold some information relevant to autoconfiguration for each address.

</p>
<p>
For each address in the network, a 'State Tuple'
(S_main_addr, S_time, S_state,
 S_last_hello_time, S_last_hello_seq_num,
 S_last_tc_time, S_last_tc_seq_num, 
 S_conflict_time,
 S_MPR_remember_time, S_MPR_forced_time, 
 S_creation_time)
is recorded.
</p>
<p>A state tuple primarily records information about
the autoconfiguration state  of the node,
but also with a set of data about these addresses, which
are used to perform autoconfiguration.
</p>
<p></p>
<blockquote class="text">
<li>S_main_addr: the address of the node
</li>
<li>S_state: the autoconfiguration state of the address 
(see <a class="info" href="#sec:state">Section 4.5<span>Autoconfiguration State</span></a>)
</li>
<li>S_time: the time after which the tuple should be deleted
</li>
<li>S_last_hello_time, S_last_hello_seq_num:   
the last time an HELLO has been received from this address, and the
sequence number of this last HELLO
</li>
<li>S_last_tc_time, S_last_tc_seq_num:
the last time an TC has been received from this address (as originator), 
and the sequence number of this last TC
</li>
<li>S_conflict_time: the time until which the address is considered to be
    in conflict
</li>
<li>S_MPR_remember_time: the time after which the node forgets that this
   address was selected as MPR by this node. 
   
</li>
<li>S_MPR_forced_time: the time during which this address must be choosen as MPR

</li>
<li>S_creation_time: the time at which the state tuple was created
</li>
</blockquote>

<a name="rfc.section.5.2.3"></a><h4><a name="sec:duplicate-set">5.2.3</a>&nbsp;Duplicate Set</h4>

<p>
In the standard OLSR protocol, each node recorded a
"Duplicate Tuple" which includes the following fields 
(D_addr, D_seq_num, D_retransmitted, D_iface_list, D_time)
(see section 3.4 of the OLSR specification <a class="info" href="#RFC3626">[3]<span>Clausen, T. and P. Jacquet, Optimized Link State Routing Protocol (OLSR), October 2003.</span></a> where they are documented). 

</p>
<p>
In NOA-OLSR, the following field is added:
D_content_id. D_content_id is used to identify the content of the message which
was received, and is should be a sequence of bytes. 
Use and requirement of D_content_id are highlighted in the next section.

</p>
<a name="rfc.section.5.2.3.1"></a><h4><a name="sec:content-identifier">5.2.3.1</a>&nbsp;Message Content Identifier</h4>

<p>
A message content identifier is used by NOA-OLSR to check whether
the content of a message is identical to one received previously.
In standard OLSR functionning, the message sequence numbers are used for this
purpose ; however in NOA-OLSR, because of the possibility of
duplicate addresses, two messages with same originator address and same
sequence number can be different if they are originated from conflicting
nodes. The message content identifier is used in this context, to verify
whether the message are actually identical.
</p>
<p>Each implementation must have a method to generate message content
identifiers from a received message, and such a method is naturally
denoted "Message Content Identifier Generation Method". 
It is typically some kind of hash method, and it should
met the following requirements:
</p>
<blockquote class="text">
<li>It must take in input the message content, and output one "message
content identifier" (whose exact implementation is left to implementors).
The message content is defined as the sequence of bytes of
an OLSR message, excluding the message header (section 3.3.2 of the OLSR specification <a class="info" href="#RFC3626">[3]<span>Clausen, T. and P. Jacquet, Optimized Link State Routing Protocol (OLSR), October 2003.</span></a>).
</li>
<li>It must consistently generate the same message content identifier,
when it is applied on the same message content.
</li>
<li>It should generate different message content identifiers, for different
message contents, with a high probability (typically larger than the
probability of address collision of one node).
</li>
</blockquote><p>
Two examples of methods which satisfy the requirements are the following:
</p>
<blockquote class="text">
<li>Copy method: the message content identifier is the sequence of bytes
which constitute the message content itself.
</li>
<li>Hash method: the message content identifier is a sequence of bytes
obtained after applying a hash function on the sequence of bytes of the
message content. For instance the MD5 Message-Digest Algorithm 
<a class="info" href="#RFC1321">[2]<span>Rivest, R., The MD5 Message-Digest Algorithm, April 1992.</span></a>, suitable at least for networks 
with less that one billion  of OLSR nodes. 
</li>
</blockquote>

<p>
Because the message content identifiers are not transmitted to other nodes,
different nodes can implement different generation methods without 
compromising interoperability.

</p>
<a name="rfc.section.5.2.4"></a><h4><a name="sec:set-field">5.2.4</a>&nbsp;Set and Unset Fields</h4>

<p>
Several of the newly introduced fields in the miscellanous tuple
are not necessarily initialized at the tuple set creation.
Such fields are:
</p>
<blockquote class="text">
<li>In state tuples, the fields: S_last_hello_time, S_last_hello_seq_num,
S_last_tc_time,
S_last_tc_seq_num, S_conflict_time, S_MPR_remember_time, S_MPR_forced_time
</li>
<li>In duplicate tuples, the field D_content_id
</li>
</blockquote><p>
After tuple creation, the node must be able to identify the
fact that the field has been already set or not. 
How to do so is indeed an implementation issue, but
in the remaining it is assumed that a node can verify whether a field
"is set" which means that a value has
been affected to the field yet. In the opposite case, the field "is not set".

</p>
<a name="rfc.section.5.3"></a><h4><a name="sec:spec-selection">5.3</a>&nbsp;Address Selection and Address Change</h4>

<a name="rfc.section.5.3.1"></a><h4><a name="sec:spec-address-selection">5.3.1</a>&nbsp;Address Selection</h4>

<p>A node can choose an address using any algorithm, as highlighted in
<a class="info" href="#sec:address-selection">Section 4.2<span>Address Selection</span></a>, subject to one constraint.
The only constraint is that the address MUST NOT select any busy address,
that is an address which has recently been used in the network.

</p>
<p>Precisely, a busy address is an address such that:
</p>
<ul class="text"><a name="anchor80"></a>
<li>There exists a State Tuple in the State Set with:
<ul class="text">
<li>S_main_addr == the given address ; and
</li>
<li>S_time is not expired
</li>
</ul>
</li>
</ul>

<p>
Hence it is required that either the address selection algorithm yields 
addresses which are different from any such addresses, or alternatively,
that the algorithm run until the last address it generates is no longer busy.
In case the algorithm is unable to generate a new address, the node may
stop.

</p>
<a name="rfc.section.5.3.2"></a><h4><a name="sec:spec-address-change">5.3.2</a>&nbsp;Address Change</h4>

<p>Upon detection of a conflict a node MUST change its address,
by selecting a new one
as described in <a class="info" href="#sec:spec-address-selection">Section 5.3.1<span>Address Selection</span></a>.
</p>
<p>When a node sets a new address (for initialisation, or because it has
just changed its address because of a conflict), the node SHOULD perform
the following steps:

</p>
<blockquote class="text">
<li>The node sets its autoconfiguration state to HELLO_STATE.
</li>
<li>Any potential OLSR message waiting for transmission or forwarding
at the routing protocol level, should be either send with the
new proper address (originator), or should be discarded.
</li>
<li>Each link tuple of the Link Set must be modified so that 
 L_local_iface_addr (which should be the previous address of the node),
 is set to new address.
</li>
<li>The MPR Selector Set is emptied.
</li>
<li>The routing table is emptied.
</li>
</blockquote>

<p>
Additionally, the autoconfiguration state evolves as follows:
</p>
<blockquote class="text">
<li>Also each time a conflict is detected, the node selects a new address
   and restarts from HELLO_STATE.
</li>
<li>If the node has been in state HELLO_STATE without address conflict
   for a duration greater than HELLO_STATE_DURATION, then:
   
<blockquote class="text">
<li>The node sets its autoconfiguration state to TOPOLOGY_STATE
</li>
<li>The node recomputes its MPR set
</li>
</blockquote>
</li>
<li>If the node has been in state TOPOLOGY_STATE without address conflict
   for a duration greater than TOPOLOGY_STATE_DURATION, then:
   
<blockquote class="text">
<li>The node sets its autoconfiguration state to NORMAL_STATE
</li>
<li>The node recomputes its MPR set
</li>
<li>The node recalculates its routing table
</li>
</blockquote>
</li>
</blockquote>

<a name="rfc.section.5.4"></a><h4><a name="anchor7">5.4</a>&nbsp;State Set Update</h4>

<p>
The State Set records information that the node gathered about all the
addresses which are known in the network. It is updated by a variety of means
at different steps of the OLSR processing.

</p>
<a name="rfc.section.5.4.1"></a><h4><a name="sec:state-set-population">5.4.1</a>&nbsp;Populating the State Set</h4>

<p>
One of the main informations that State Set records is whether an address
has already been seen in the network, and what was the 
autoconfiguration state associated with that address.

</p>
<p>
Because all external addresses of the network come from OLSR 
messages received, such messages are the source of information used to
populate the State Set. Because state tuples may be used quite early
in the processing, the node MUST satisfy the following requirements:
</p>
<ul class="text">
<li>For any address which is to be used, the node must preliminary
  update its state tuple with the proper associated autoconfiguration
  state if it is know, or with the STATE_UNDEFINED autoconfiguration state.
  
</li>
</ul>

<p>More precisely, in the basic functionning of the OLSR protocol, 
TC and HELLO messages are exchanged and upon receiving such a message,
and:
</p>
<ul class="text">
<li>The node should update the state tuple of Sender Interface Address 
with STATE_UNDEFINED (as per <a class="info" href="#sec:state-tuple-update">Section 5.4.2<span>State Tuple Update</span></a>).
</li>
<li>The node should update the state tuple of the Originator Address
with STATE_UNDEFINED (as per <a class="info" href="#sec:state-tuple-update">Section 5.4.2<span>State Tuple Update</span></a>).
</li>
<li>Depending on the message type, it should perform the following updates if
   it is one of the following:
  
<ul class="text">
<li>HELLO_MESSAGE, HELLO_MESSAGE_WITH_STATE: update the state set
  according to <a class="info" href="#sec:hello-processing-state">Section 5.6.2.1<span>State Set Update from HELLO</span></a>
</li>
<li>TC_MESSAGE, TC_MESSAGE_WITH_STATE: update the state set
  according to <a class="info" href="#sec:tc-processing-state">Section 5.6.5.1<span>State Set Update from TC</span></a>
</li>
</ul>
</li>
</ul>

<a name="rfc.section.5.4.2"></a><h4><a name="sec:state-tuple-update">5.4.2</a>&nbsp;State Tuple Update</h4>

<p>
This section describes the steps taken for the action refered in other
sections as: updating the state tuple for a given address "Address"
with a given state "Autoconfiguration State".
The steps are the following:
</p>
<ul class="text">
<li>If there exists no state tuple where:
    
<blockquote class="text">
<p>S_main_addr == given Address
</p>
</blockquote><p>
    then one is created and inserted in the tuple set with the following
    values:
    </p>
<ul class="text">
<li>S_main_addr = given Address
</li>
<li>S_creation_time = current time
</li>
<li>S_state = STATE_UNDEFINED
</li>
<li>S_MPR_remember_time is not set
</li>
<li>S_MPR_forced_time is not set
</li>
<li>S_conflict_time is not set
</li>
<li>S_last_hello_time is not set
</li>
<li>S_last_tc_time is not set
</li>
</ul>
</li>
<li>The state tuple (newly created or not) where
    
<blockquote class="text">
<p>S_main_addr == given Address
</p>
</blockquote><p>
   is then modified as follows:
   </p>
<blockquote class="text">
<p>S_time = current time + NODE_STATE_HOLD_TIME
</p>
</blockquote><p>
   After that, if the following condition is true:
   </p>
<blockquote class="text">
<p>the given Autoconfiguration State is different from
        STATE_UNDEFINED, AND
</p>
<p>S_state is different from the given Autoconfiguration State
</p>
</blockquote><p>
   Then a potential topology change is recorded 
   and the state tuple is modified as follows:
   </p>
<ul class="text">
<li>S_state = given Autoconfiguration state
</li>
</ul>
</li>
</ul><p>

A potential topology change implies that both
the MPR set and the routing table SHOULD be recomputed.
</p>
<a name="rfc.section.5.4.3"></a><h4><a name="sec:state-tuple-retrieve">5.4.3</a>&nbsp;Associated State Tuple Retrieval</h4>

<p>
In many cases, the steps related to autoconfiguration
use the state tuple associated to one address, that is: the state
tuple such as S_main_addr is equal to that address
(it is necessarily unique).
If such a state tuple exists, then this is the one which is used when
the "associated state tuple is retrieved".

</p>
<p>However, although such a state tuple should exist, 
it may be the case that such a state tuple has been deleted,
because S_time has expired.
This is because the state set is kept relatively independent from other
processings and from other sets by design. 
When this case occurs when the
"associated state tuple is retrieved", a new state tuple is created
using the method in <a class="info" href="#sec:state-tuple-update">Section 5.4.2<span>State Tuple Update</span></a>
(using STATE_UNDEFINED).


</p>
<a name="rfc.section.5.4.4"></a><h4><a name="anchor8">5.4.4</a>&nbsp;State Tuple: HELLO information update</h4>

<p>
Each time the handling of a received HELLO message has been finished, the
state tuple of its originator, that is the state tuple where:
</p>
<blockquote class="text">
<p>S_main_addr == Originator Address
</p>
</blockquote><p>
will exist (as an application of the rules
<a class="info" href="#sec:state-set-population">Section 5.4.1<span>Populating the State Set</span></a>).
The node should then update or ensure that it had been updated as follows:
</p>
<blockquote class="text">
<p>S_last_hello_time    = current time
</p>
<p>S_last_hello_seq_num = HELLO message sequence number
</p>
</blockquote>

<a name="rfc.section.5.4.5"></a><h4><a name="anchor9">5.4.5</a>&nbsp;State Tuple: TC information update</h4>

<p>
Each time the handling of a received TC message has been finished, the
state tuple of its originator, that is the state tuple where:
</p>
<blockquote class="text">
<p>S_main_addr == Originator Address
</p>
</blockquote><p>
will exist (as an application of the rules
<a class="info" href="#sec:state-set-population">Section 5.4.1<span>Populating the State Set</span></a>).
The node should then update or ensure that it had been updated as follows:
</p>
<blockquote class="text">
<p>S_last_tc_time    = current time
</p>
<p>S_last_tc_seq_num = TC message sequence number
</p>
</blockquote>

<a name="rfc.section.5.4.6"></a><h4><a name="sec:state-mpr-remember">5.4.6</a>&nbsp;State Tuple: MPR information update</h4>

<p>
Before recomputing its MPR set, as documented in section 8.3 of the OLSR specification <a class="info" href="#RFC3626">[3]<span>Clausen, T. and P. Jacquet, Optimized Link State Routing Protocol (OLSR), October 2003.</span></a>, 
a node MUST use the current list of MPR to save the information that 
those nodes had been choosen as MPR in the recent past. 
This is used for DAD rule <a class="info" href="#rule:R6">Section 4.3.5.2.1<span>Rule R6</span></a>.

</p>
<p>
For each address in its MPR set, the associated state tuple
is retrieved (as per <a class="info" href="#sec:state-tuple-retrieve">Section 5.4.3<span>Associated State Tuple Retrieval</span></a>),
and is modified as follows:
</p>
<ul class="text">
<li>S_MPR_remember_time = current time + MAX_MPR_REMEMBER_TIME
</li>
</ul>

<a name="rfc.section.5.4.7"></a><h4><a name="sec:spec-familiarity">5.4.7</a>&nbsp;Familiarity</h4>

<p>
The concept of familiar addresses, which is described
in <a class="info" href="#sec:familiarity">Section 4.6<span>Node Familiarity</span></a>, is used by NOA-OLSR.
In the actual specification,
the fact that a given address is familiar or unfamiliar 
is determined from the state set, as follows:
</p>
<ol class="text">
<li>If there exists a state tuple in the state set, such as:
  
<blockquote class="text">
<p>S_main_addr = given address, AND
</p>
<p>current time &gt; S_creation_time + NODE_FAMILIAR_TIME
</p>
</blockquote><p>
  then: the address is familiar

</li>
<li>Otherwise, the address is unfamiliar.
</li>
</ol>
</p>
<a name="rfc.section.5.5"></a><h4><a name="XXX-1">5.5</a>&nbsp;Changes in Message Processing</h4>

<a name="rfc.section.5.5.1"></a><h4><a name="XXX-2">5.5.1</a>&nbsp;Overview</h4>

<p>
This section gives a description of the changes in the processing of standard
OLSR messages, namely HELLO messages and TC messages.
</p>
<a name="rfc.section.5.5.2"></a><h4><a name="sec:spec-processing">5.5.2</a>&nbsp;Packet Processing and Message Flooding</h4>

<p>The packet processing algorithm, documented
in section 3.4 of the OLSR specification <a class="info" href="#RFC3626">[3]<span>Clausen, T. and P. Jacquet, Optimized Link State Routing Protocol (OLSR), October 2003.</span></a>, has been changed. For convenience,
such changes have been denoted "message pre-processing" and
"message post-processing". Hence,
an autoconfiguration pre-processing step and
an autoconfiguration post-processing step have been added to the
message processing of the standard OLSR.

</p>
<p>Upon receiving a OLSR packet, a node MUST perform a number of
tasks for each encapsulated message, listed in section 3.4 of the OLSR specification <a class="info" href="#RFC3626">[3]<span>Clausen, T. and P. Jacquet, Optimized Link State Routing Protocol (OLSR), October 2003.</span></a>. 
The steps which have been added or changed are the following:
</p>
<blockquote class="text"><dl>
<dt>1</dt>
<dd>...
</dd>
<dt>1 bis</dt>
<dd>{CHANGED:}Depending on whether or not the node
has decided to interoperate with standard OLSR nodes 
(see <a class="info" href="#sec:interoperability-modified">Section 8.2<span>Interoperability with Standard OLSR</span></a>), the node
MUST check whether it must reject the message based on 
requirements of <a class="info" href="#sec:spec-message-type">Section 5.6.7<span>Message Type for HELLO and TC Messages</span></a>. It the message
must be rejected, the processing of the message stops here.
 
</dd>
<dt>2</dt>
<dd>If the time to live of the message is less than or
equal to '0' (zero), the message MUST silently be dropped. {CHANGED:}
Even if the message was sent by the receiving node
(i.e., the Originator Address of the message is the main address of
the receiving node), the 
node MUST perform the autoconfiguration pre-processing given
indicated in <a class="info" href="#sec:pre-processing">Section 5.5.3<span>Autoconfiguration Message Pre-Processing</span></a>. This pre-processing
will finish with one of four statuses:
  
<blockquote class="text"><dl>
<dt>Address conflict detected</dt>
<dd>The node MUST then stop the
  processing of the packet and change its address according to the rules of 
  <a class="info" href="#sec:spec-address-change">Section 5.3.2<span>Address Change</span></a>.
</dd>
<dt>Interrupt message processing</dt>
<dd>The node MUST then skip the
  processing of the current message, and proceed to the processing 
  of the next message (if any) of the packet.
</dd>
<dt>Retransmit message and interrupt message processing</dt>
<dd>
  The node MUST first perform a special retransmission of the 
message according to the 
rules listed in <a class="info" href="#sec:special-retransmission">Section 5.5.2.1<span>Special Retransmission</span></a>, then skip the
  processing of the current message, and proceed to the processing 
  of the next message (if any) of the packet.
</dd>
<dt>Continue message processing</dt>
<dd>The node MUST continue the
   processing of the message.
</dd>
</dl></blockquote>
</dd>
<dt>3 ... 4</dt>
<dd> (same as in section 3.4 of the OLSR specification <a class="info" href="#RFC3626">[3]<span>Clausen, T. and P. Jacquet, Optimized Link State Routing Protocol (OLSR), October 2003.</span></a>)
</dd>
<dt>5</dt>
<dd> {CHANGED:} the message SHOULD be post-processed according the 
the specifications of <a class="info" href="#sec:post-processing">Section 5.5.4<span>Autoconfiguration Message Post-Processing</span></a>.
</dd>
</dl></blockquote>

<a name="rfc.section.5.5.2.1"></a><h4><a name="sec:special-retransmission">5.5.2.1</a>&nbsp;Special Retransmission</h4>

<p>
A special retransmission method is used when it is assumed, that,
in presence of address conflict, the MPR flooding mechanism alone
would not necessarily guarantee the proper distribution of one message
to the entire network. This retransmission can be performed as a result
of the message pre-processing steps, it includes creation of a new duplicate
tuple, followed by a retransmission of the message section 3.4.1 of the OLSR specification <a class="info" href="#RFC3626">[3]<span>Clausen, T. and P. Jacquet, Optimized Link State Routing Protocol (OLSR), October 2003.</span></a>:

</p>
<ol class="text">
<li>A new duplicate tuple is inserted in the duplicate set with the special
    duplicate tuple creation documented in 
     <a class="info" href="#sec:special-duplicate">Section 5.5.2.2<span>Special Duplicate Tuple Creation</span></a>.
  
</li>
<li>The TTL of the message is reduced by one. 
</li>
<li>The hop-count of the message is increased by one.
</li>
<li>The message is broadcast on all interfaces (Notice: the remaining 
    fields of the message header SHOULD be left unmodified.)
</li>
</ol>

<a name="rfc.section.5.5.2.2"></a><h4><a name="sec:special-duplicate">5.5.2.2</a>&nbsp;Special Duplicate Tuple Creation</h4>

<p>
This document uses the duplicate set in additional ways differing from the 
<a class="info" href="#RFC3626">standard OLSR<span>Clausen, T. and P. Jacquet, Optimized Link State Routing Protocol (OLSR), October 2003.</span></a>[3]. Indeed,
the duplicate set is also used for both messages generated by the node
 and for messages retransmitted using the
<a class="info" href="#sec:special-retransmission">Special Retransmission<span>Special Retransmission</span></a> 
method. Such use relies on the creation of a duplicate tuple in a
special way by one method, herehence called "Special Duplicate Tuple
Creation". The duplicate tuple is created for a given message,
and refering to the fields of the message, it is created as follows:
    </p>
<blockquote class="text">
<p>D_addr          = Originator Address
</p>
<p>D_seq_num       = Message Sequence Number
</p>
<p>D_retransmitted = true
</p>
<p>D_time          = current time + DUP_HOLD_TIME
</p>
<p>D_iface_list contains all the interfaces of the node

</p>
<p>D_content_id    = computed message content identifier 
         (<a class="info" href="#sec:content-identifier">Section 5.2.3.1<span>Message Content Identifier</span></a>)
</p>
</blockquote>

<a name="rfc.section.5.5.3"></a><h4><a name="sec:pre-processing">5.5.3</a>&nbsp;Autoconfiguration Message Pre-Processing</h4>

<p>
This section specifies the message pre-processing which MUST be implemented.
Note that the message pre-processing uses the message headers
but doesn't interpret (parse) the message content ;
instead it considers the message content as a sequence of bytes.

</p>
<p>
The following steps MUST be followed:
</p>
<ol class="text">
<li>If the message  is a HELLO_MESSAGE or HELLO_WITH_STATE_MESSAGE, the
node pre-processes the messages according to 
<a class="info" href="#sec:hello-pre-processing">Section 5.5.3.1<span>Hello Message Pre-Processing</span></a>.
</li>
<li>Otherwise, if the message is a TC_MESSAGE or TC_WITH_STATE_MESSAGE,
the node pre-processes the messages according to 
<a class="info" href="#sec:tc-pre-processing">Section 5.5.3.2<span>TC Message Pre-Processing</span></a>.
</li>
<li>Otherwise:
  
<ol class="text">
<li>If the message was sent by the receiving node
          (i.e., the Originator Address of the message is the main
          address of the receiving node) the message pre-processing 
         finish with status 'Interrupt Message Processing'
</li>
<li>Otherwise, this pre-processing finishes with status
     'Continue Message Processing'.
</li>
</ol>
</li>
</ol>

<a name="rfc.section.5.5.3.1"></a><h4><a name="sec:hello-pre-processing">5.5.3.1</a>&nbsp;Hello Message Pre-Processing</h4>

<p>
The pre-processing of such messages MUST be performed as follows,
checking for the <a class="info" href="#rule:R1">R1<span>Rule R1</span></a>.

</p>
<ol class="text">
<li>If the Originator Address of the message is the main
   address of the receiving node:
  
<ol class="text">
<li>there is a conflict and the pre-processing finishes with 
     status 'Address conflict detected'
(in accordance to DAD rule <a class="info" href="#rule:R1">R1<span>Rule R1</span></a>)

</li>
</ol>
</li>
<li> Otherwise, the pre-processing finishes with status
'Continue message processing'
</li>
</ol>

<a name="rfc.section.5.5.3.2"></a><h4><a name="sec:tc-pre-processing">5.5.3.2</a>&nbsp;TC Message Pre-Processing</h4>

<p>
The pre-processing of such message MUST be performed checking
for the DAD rules <a class="info" href="#rule:R4">R4<span>Rule R4</span></a> and
<a class="info" href="#rule:R7">R5<span>Rule R7</span></a> as follows:

</p>
<a name="rfc.section.5.5.3.2.1"></a><h4><a name="anchor10">5.5.3.2.1</a>&nbsp;Rule R4 check</h4>

<p></p>
<ul class="text">
<li>If the following condition is true:
    
<blockquote class="text">
<p>Originator Address == main address of the node
</p>
</blockquote>
</li>
<li>AND if there exists no tuple in the tuple set where:
       
<blockquote class="text">
<p>D_addr    == Originator Address, AND
</p>
<p>D_seq_num == Message Sequence Number
</p>
<p>D_content_id == computed message content identifier
</p>
</blockquote>
</li>
<li>then, in accordance to rule <a class="info" href="#rule:R4">R4<span>Rule R4</span></a>,
       a conflict as been detected and the pre-processing is finished
       with status 'Address conflict detected'.
</li>
</ul>

<a name="rfc.section.5.5.3.2.2"></a><h4><a name="anchor11">5.5.3.2.2</a>&nbsp;Rule R5 check</h4>

<p>The DAD rule R5 requires checking two conditions, namely,
consistency of sequence numbers of TC messages, 
and consistency of message content of TC messages.

</p>
<p>The check for consistent sequence numbers is the following:
</p>
<ul class="text">
<li>If the following condition is true:
    
<ul class="text">
<li>Originator Address is different from main address of the node
</li>
</ul><p>
    AND such TC has never been seen, that is: there exists no tuple in
    the duplicate set where:
    </p>
<blockquote class="text">
<p>D_addr    == Originator Address, AND
</p>
<p>D_seq_num == Message Sequence Number
</p>
</blockquote><p>
    AND a TC sequence number inconsistency is detected
  using the rules of <a class="info" href="#sec:tc-consistency">Section 4.4.3<span>TC Sequence Number Consistency</span></a>, that is,
  precisely: there exists one tuple in the state set where:
    </p>
<blockquote class="text">
<p>S_main_addr == Originator Address, AND
</p>
<p>S_last_tc_time is set , AND
</p>
<p>| Message Sequence Number - S_last_tc_seq_um | > MAX_TC_DIFF_SEQ_NUM,
          (where |a| is the absolute value of 'a'), AND
</p>
<p>| Message Sequence Number - S_last_tc_seq_um | > 
          (current time - S_last_tc_time) * MAX_MESSAGE_RATE
         
</p>
</blockquote><p>
    then, in accordance to rule <a class="info" href="#rule:R5">R5<span>Rule R5</span></a> a conflict
    has been detected between two other nodes, and the pre-processing is
    finished with status 'Retransmit message and interrupt message processing'.
  
</li>
</ul>
</p>
<p>The check for consistent TC message content is the following:
</p>
<ul class="text">
<li>If the following condition is true:
    
<ul class="text">
<li>Originator Address is different from main address of the node
</li>
</ul><p>
    AND such TC has been seen, that is: there exists at least one tuple in
    the duplicate set where: </p>
<blockquote class="text">
<p>D_addr    == Originator Address, AND
</p>
<p>D_seq_num == Message Sequence Number
</p>
</blockquote><p>
    AND there exists no tuple in the duplicate set where: 
    </p>
<blockquote class="text">
<p>D_addr       == Originator Address, AND
</p>
<p>D_seq_num    == Message Sequence Number, AND
</p>
<p>D_content_id == computed message content identifier 
           (see <a class="info" href="#sec:content-identifier">Section 5.2.3.1<span>Message Content Identifier</span></a>)
</p>
</blockquote><p>
    then, in accordance to rule <a class="info" href="#rule:R5">R5<span>Rule R5</span></a> a conflict
    has been detected between two other nodes, and the pre-processing is
    finished with status 'Retransmit message and interrupt message processing'.
  
</li>
</ul>
</p>
<a name="rfc.section.5.5.4"></a><h4><a name="sec:post-processing">5.5.4</a>&nbsp;Autoconfiguration Message Post-Processing</h4>

<p>
The node MUST do the following post-processing, to ensure that any
forwared TC has an associated duplicate tuple with proper D_content_id:
</p>
<ol class="text">
<li>If the message is a TC_MESSAGE or a TC_WITH_STATE_MESSAGE:
    
<ul class="text">
<li>If there exists a duplicate tuple such that:
      
<blockquote class="text">
<p>D_addr    == Originator Address, AND
</p>
<p>D_seq_num == Message Sequence Number, AND
</p>
<p>D_content_id is not set
</p>
</blockquote>
</li>
<li>Then:
      
<blockquote class="text">
<p>The field D_content_id of this duplicate tuple is set to 
           the value of the computed message content identifier
           (<a class="info" href="#sec:content-identifier">Section 5.2.3.1<span>Message Content Identifier</span></a>).
        
</p>
</blockquote>
</li>
</ul>
</li>
<li>Otherwise the post-processing stops.
</li>
</ol>

<a name="rfc.section.5.6"></a><h4><a name="anchor12">5.6</a>&nbsp;Changes in OLSR Message Processing</h4>

<p>
This section documents the changes to be applied in
the general processing of the OLSR protocol: OLSR message processing
for HELLO and TC messages.

</p>
<a name="rfc.section.5.6.1"></a><h4><a name="sec:change-hello-format">5.6.1</a>&nbsp;Changes in HELLO Message Format</h4>

<p>A new kind of HELLO message is used: it includes now both the
autoconfiguration state of the node which generates the HELLO and the 
autoconfiguration state of neighbor interface addresses. The Message Type
of the message is HELLO_WITH_STATE_MESSAGE
(see also <a class="info" href="#sec:spec-message-type">Section 5.6.7<span>Message Type for HELLO and TC Messages</span></a>).
</p>
<p>Although another general format might be used, it is choosen to keep
the format of a message HELLO_WITH_STATE is similar to a normal HELLO,
except for the following:
the reserved field is split in two and includes
the state of the nodes (for the originator of the HELLO,
and the neighbor nodes),
as shown on <a class="info" href="#fig:hello-with-state">Figure 14</a>.

</p><a name="fig:hello-with-state"></a>
<pre>
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |  Node State   | Neigh. State  |     Htime     |  Willingness  |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |   Link Code   |   Reserved    |       Link Message Size       |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                  Neighbor Interface Address                   |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     ...
</pre>
<table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure 14&nbsp;</b></font><br /></td></tr></table><hr size="1" shade="0">

<p>
"Node State" is the autoconfiguration state of the node.
"Neighbor State" ("Neigh. State") 
is the autoconfiguration state of the neighbors being advertised.

</p>
<p>
As a result, only neighbors which all have the same autoconfiguration
state can be sent in the same
HELLO_WITH_STATE: this is not restrictive in practice, because several
different HELLO_WITH_STATE can be generated at the same time (each with 
different neighbor state).
</p>
<p>
The choice if which of HELLO or HELLO_WITH_STATE to use,
is specified in <a class="info" href="#sec:spec-message-type">Section 5.6.7<span>Message Type for HELLO and TC Messages</span></a>.

</p>
<a name="rfc.section.5.6.2"></a><h4><a name="sec:change-hello-processing">5.6.2</a>&nbsp;Changes in HELLO Message Processing</h4>

<p>
The HELLO Message Processing modifies on the processing
described in section 7.1.1 of the OLSR specification <a class="info" href="#RFC3626">[3]<span>Clausen, T. and P. Jacquet, Optimized Link State Routing Protocol (OLSR), October 2003.</span></a>,
in section 8.2.1 of the OLSR specification <a class="info" href="#RFC3626">[3]<span>Clausen, T. and P. Jacquet, Optimized Link State Routing Protocol (OLSR), October 2003.</span></a>, 
and in section 8.4.1 of the OLSR specification <a class="info" href="#RFC3626">[3]<span>Clausen, T. and P. Jacquet, Optimized Link State Routing Protocol (OLSR), October 2003.</span></a>.

</p>
<p>
The changes in the HELLO Message Processing are related to
the DAD rules <a class="info" href="#rule:R2">R2<span>Rule R2</span></a>, 
  <a class="info" href="#rule:R3">R3<span>Rule R3</span></a>, 
  and <a class="info" href="#rule:R12">R12<span>Rule R12</span></a>.

</p>
<p>
The "Originator Address" of a HELLO message is the main address of
the node, which has emitted the message. Likewise, the "Neighbor State"
MUST be computed from the Neighbor State field of the HELLO message
(see <a class="info" href="#sec:change-hello-format">Section 5.6.1<span>Changes in HELLO Message Format</span></a>).

</p>
<p>The application of the <a class="info" href="#rule:R2">DAD rule R2<span>Rule R2</span></a>
is done by performing the following processing with the message originator
address:
</p>
<ol class="text">
<li>The state tuple relative to the Originator Address  of the message 
  is updated (see <a class="info" href="#sec:state-tuple-update">Section 5.4.2<span>State Tuple Update</span></a>)
  with autoconfiguration state equal to the Neighbor State.
</li>
<li>If that associated state tuple verifies:
    
<ul class="text">
<li>S_last_hello_seq_num is set, AND
</li>
<li>current time - S_last_hello_time &lt; MIN_WRAP_AROUND_INTERVAL,
         AND
</li>
<li>S_last_hello_seq_num is equal or greater 
         to the Message Sequence Number of the received HELLO
</li>
</ul><p>
    then the Originator is conflicting with another node, according to rule
    <a class="info" href="#rule:R2">R2<span>Rule R2</span></a>, and as a consequence, the state tuple
    MUST be updated as follow:
    </p>
<ul class="text">
<li>S_conflict_time = current time + CONFLICT_HOLD_TIME
</li>
</ul>
</li>
</ol>

<p>The application of the DAD rule <a class="info" href="#rule:R3">R3<span>Rule R3</span></a>
is done by checking whether the address of the node is advertised 
by the means of <a class="info" href="#sec:change-hello-generation">Section 5.6.3<span>Changes in HELLO Message Generation</span></a> in
the HELLO of another node, as follows:
</p>
<ol class="text">
<li>If inside the same HELLO message from another node, 
     the address of the node appears more than one time, then:
    
<blockquote class="text">
<p>The node is in conflict and node MUST then stop the processing 
         of the packet and change its address according to the rules of
         <a class="info" href="#sec:spec-address-change">Section 5.3.2<span>Address Change</span></a>
</p>
</blockquote>
</li>
</ol>

<p>
The DAD rule @R12@ adds the following processing
upon receiving a HELLO message:
</p>
<ul class="text">
<li>for each address (henceforth: 2-hop neighbor address), listed 
  in the HELLO message with Neighbor Type equal to SYM_NEIGH or MPR_NEIGH:
    
<ol class="text">
<li>if the main address of the 2-hop neighbor address == main address
         of the receiving node:
         
<blockquote class="text">
<p>silently ignore the 2-hop address
</p>
</blockquote>
</li>
<li>otherwise if there exists a associated neighbor tuple where:
        
<blockquote class="text">
<p>N_neighbor_main_addr == 2-hop neighbor address, AND
</p>
</blockquote><p>
        additionally there exists no two hop neighbor tuple where:
        </p>
<blockquote class="text">
<p>N_neighbor_main_addr == 2-hop neighbor address, AND
</p>
<p>N_2hop_addr == Originator address
</p>
</blockquote><p>
        then, a potential conflict is assumed and:
        </p>
<ul class="text">
<li>state tuple associated to the 2-hop neighbor address is retrieved
             (see <a class="info" href="#sec:state-tuple-retrieve">Section 5.4.3<span>Associated State Tuple Retrieval</span></a>), and
             it is updated as follows:
</li>
<li>S_MPR_forced_time = current time + CONFLICT_HOLD_TIME
</li>
</ul>
</li>
</ol>
</li>
</ul>

<p>
Additionally,
the node would now process its own HELLO messages, because one check
has been removed in <a class="info" href="#sec:spec-processing">Section 5.5.2<span>Packet Processing and Message Flooding</span></a>. This should
be avoided, hence
now prior to performing the HELLO processing of section 7.1.1 of the OLSR specification <a class="info" href="#RFC3626">[3]<span>Clausen, T. and P. Jacquet, Optimized Link State Routing Protocol (OLSR), October 2003.</span></a>,
the node should check that:
</p>
<blockquote class="text">
<p>The Originator Address of HELLO message is not one of the main
    address of node
</p>
</blockquote><p>
and if it is not the case, the standard HELLO processing should be skipped.


</p>
<a name="rfc.section.5.6.2.1"></a><h4><a name="sec:hello-processing-state">5.6.2.1</a>&nbsp;State Set Update from HELLO</h4>

<p>
The "Originator Address" of a HELLO message is the main address of
the node, which has emitted the message, and is in the message header
of the message (section 3.3.2 of the OLSR specification <a class="info" href="#RFC3626">[3]<span>Clausen, T. and P. Jacquet, Optimized Link State Routing Protocol (OLSR), October 2003.</span></a>).

The "Node State" and the "Neighbor State" are fields inside the HELLO message
and have been added for NOA-OLSR (see 
<a class="info" href="#sec:change-hello-format">Section 5.6.1<span>Changes in HELLO Message Format</span></a>).

Upon receiving a HELLO, and before any processing of the content (i.e. before
using any of the addresses), the node SHOULD update the state set as follows:
</p>
<ol class="text">
<li>The state tuple associated to Originator Address must be updated
    with the autoconfiguration state "Node State" 
    (as per <a class="info" href="#sec:state-tuple-update">Section 5.4.2<span>State Tuple Update</span></a>)
  
</li>
<li>For each of the neighbor interface address received in
     the HELLO message:
     
<ol class="text">
<li>The state tuple associated to neighbor interface address must 
          be updated with the autoconfiguration state "Neighbor State"
       
</li>
</ol>
</li>
</ol>

<a name="rfc.section.5.6.3"></a><h4><a name="sec:change-hello-generation">5.6.3</a>&nbsp;Changes in HELLO Message Generation</h4>

<p>
The HELLO Message Generation is the one described in section 6.2 of the OLSR specification <a class="info" href="#RFC3626">[3]<span>Clausen, T. and P. Jacquet, Optimized Link State Routing Protocol (OLSR), October 2003.</span></a>,
with modifications described in this section.
There are two modifications. The first one is the application of the 
the DAD rule <a class="info" href="#rule:R3">Section 4.3.4.2<span>Rule R3</span></a> and is related to rule
<a class="info" href="#rule:R2">Section 4.3.4.1<span>Rule R2</span></a>:
the address of neighbors which have been detected to be in conflict 
are advertised in the HELLO messages. There are implicitly advertised
by a specific means: they are included twice in the HELLO message.
The second modification relates to the specification of the autoconfiguration
states in the messages.

</p>
<p>
The amendments of section 6.2 of the OLSR specification <a class="info" href="#RFC3626">[3]<span>Clausen, T. and P. Jacquet, Optimized Link State Routing Protocol (OLSR), October 2003.</span></a> are hence:
</p>
<ul class="text">
<li>The Node State field is set such that it corresponds to the node's
current autoconfiguration state.
</li>
<li>The Neighbor State field is set such that it corresponds to the
autoconfiguration state of all addresses listed in the HELLO messages.
Namely, for any Neighbor Interface Address which is advertised,
it MUST be advertised in an HELLO message such that:
  
<ul class="text">
<li>the associated state tuple
       (<a class="info" href="#sec:state-tuple-retrieve">Section 5.4.3<span>Associated State Tuple Retrieval</span></a>) has a S_state
       identical to the Neighbor State the message
</li>
</ul><p>
As a consequence, one node will send at least many different HELLO 
as there are different autoconfiguration states of neighbors.

</li>
<li>The following rule is added: any neighbor conflicting address, as
identified by the fact that there is one state tuple where:
  </p>
<blockquote class="text">
<p>S_main_addr == address, AND
</p>
<p>S_conflict_time > current time
</p>
</blockquote><p>
and for which there exists one associated neighbor tuple where:
  </p>
<blockquote class="text">
<p>N_neighbor_main_addr == S_main_addr
</p>
</blockquote><p>
this conflicting address MUST be cited at least once within the predetemined
refreshing period REFRESH_INTERVAL in the following way:
it must figure listed twice (or more) in the same link message,
with proper Neighbor Code, and with either proper Link Code
or LINK_UNSPEC.

</li>
</ul>
</p>
<a name="rfc.section.5.6.4"></a><h4><a name="sec:change-tc-format">5.6.4</a>&nbsp;Changes in TC Message Format</h4>

<p>A new kind of TC message is used: it includes now both the
autoconfiguration state of the node which generates the TC and the 
autoconfiguration state of advertised addresses. The Message Type
of the message is TC_WITH_STATE_MESSAGE. A similar change to
HELLO messages (see <a class="info" href="#sec:change-hello-format">Section 5.6.1<span>Changes in HELLO Message Format</span></a>) is
performed: use of the reserved field for storing an extra
Node State and Neighbor State (each of them within one byte)
</p><a name="fig:tc-with-state"></a>
<pre>
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |              ANSN             | Node State    | Neigh. State  |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |               Advertised Neighbor Main Address                |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    ...
</pre>
<table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure 15&nbsp;</b></font><br /></td></tr></table><hr size="1" shade="0">

<p>
"Node State" is the autoconfiguration state of the node.
"Neighbor State" ("Neigh. State")
is the autoconfiguration state of the neighbors being advertised.

</p>
<p>
Note that only nodes in STATE_NORMAL are sending TCs, and only nodes
in STATE_TOPOLOGY or STATE_NORMAL are selecting MPR
(as per <a class="info" href="#sec:state.functionning">Section 4.5.2<span>Functionning</span></a>), hence the possible
values in the "Node State" and "Neighbor State" fields are limited.
Still, upon receiving a TC message, the TC processing should not assume
this property is necessarily verified, for possible interoperability reasons.

</p>
<p>Additionaly,
requirements about which of TC or TC_WITH_STATE to use,
are specified in <a class="info" href="#sec:spec-message-type">Section 5.6.7<span>Message Type for HELLO and TC Messages</span></a>.

</p>
<a name="rfc.section.5.6.5"></a><h4><a name="sec:change-tc-processing">5.6.5</a>&nbsp;Changes in TC Message Processing</h4>

<p>
The TC Message Processing specified in the section 9.5 of the OLSR specification <a class="info" href="#RFC3626">[3]<span>Clausen, T. and P. Jacquet, Optimized Link State Routing Protocol (OLSR), October 2003.</span></a> is
now verifying the DAD rules <a class="info" href="#rule:R6">R6<span>Rule R6</span></a>,
<a class="info" href="#rule:R7">R7<span>Rule R7</span></a>, <a class="info" href="#rule:R8">R8<span>Rule R8</span></a> 
and <a class="info" href="#rule:R9">R9<span>Rule R9</span></a>, and additionally,
is adapted in several ways.
The following adaptions SHOULD be added:
</p>
<ul class="text">
<li>The TC processing of section 9.5 of the OLSR specification <a class="info" href="#RFC3626">[3]<span>Clausen, T. and P. Jacquet, Optimized Link State Routing Protocol (OLSR), October 2003.</span></a> and the additional TC 
     processing in this section, is only performed when
     the node is in TOPOLOGY_STATE or NORMAL_STATE.
</li>
<li>The state set should be updated from the TC messages.
</li>
<li>Some TC messages uncover an address conflict involving the receiving
     node (rule <a class="info" href="#rule:R6">R6<span>Rule R6</span></a>).
</li>
<li>Some TC messages are to be ignored because they are estimated 
  to include invalid information (rules <a class="info" href="#rule:R9">R9<span>Rule R9</span></a>).
</li>
<li>Some information in the TC messages (some addresses) should be ignored
    because it is estimated to be invalid (rules <a class="info" href="#rule:R5">R5<span>Rule R5</span></a> and @R12@).
</li>
</ul><p>
Each of these are described in the following sections.


</p>
<a name="rfc.section.5.6.5.1"></a><h4><a name="sec:tc-processing-state">5.6.5.1</a>&nbsp;State Set Update from TC</h4>

<p>
The "Originator Address" of a TC message is the main address of
the node, which has emitted the message, and is in the message header
of the message (section 3.3.2 of the OLSR specification <a class="info" href="#RFC3626">[3]<span>Clausen, T. and P. Jacquet, Optimized Link State Routing Protocol (OLSR), October 2003.</span></a>).

The "Node State" and the "Neighbor State" are fields inside the TC message
and have been added for NOA-OLSR (see 
<a class="info" href="#sec:change-tc-format">Section 5.6.4<span>Changes in TC Message Format</span></a>).

Upon receiving a TC, and before any processing of the content (i.e. before
using any of the addresses), the node SHOULD update the state set as follows:
</p>
<ol class="text">
<li>The state tuple associated to Originator Address must be updated
    with the autoconfiguration state "Node State" 
    (as per <a class="info" href="#sec:state-tuple-update">Section 5.4.2<span>State Tuple Update</span></a>)
  
</li>
<li>For each of the advertised neighbor main address received in
     the TC message:
     
<ol class="text">
<li>The state tuple associated to advertised neighbor address must 
          be updated with the autoconfiguration state "Neighbor State"
       
</li>
</ol>
</li>
</ol>

<a name="rfc.section.5.6.5.2"></a><h4><a name="sec:spec-tc-conflict">5.6.5.2</a>&nbsp;Conflict detection based on TC message content</h4>

<p>
The rule <a class="info" href="#rule:R6">R6<span>Rule R6</span></a> asserts that the node is in conflict, if it receives
a TC which advertises its address in an situation where it shouldn't.


The pratical steps for completing this check are the following:
</p>
<ul class="text">
<li>If in the received TC message:
    
<ul class="text">
<li>the advertised address includes the main address of the node, AND
</li>
<li>the originator address is not in the MPR set of the node, AND
</li>
<li>the associated state tuple  of the originator address
         is such that at least one of the two following conditions is verified:
        
<ul class="text">
<li>S_MPR_remember_time is not set, or else,
</li>
<li>S_MPR_remember_time &lt; current time
</li>
</ul>
</li>
</ul>
</li>
<li>
   Then the node is in conflict:  it will then stop the processing 
   of the message and it MUST change its address according to the rules of
   <a class="info" href="#sec:spec-address-change">Section 5.3.2<span>Address Change</span></a>.
  
</li>
</ul>

<a name="rfc.section.5.6.5.3"></a><h4><a name="sec:spec-tc-dismiss">5.6.5.3</a>&nbsp;Dismissed TC messages</h4>

<p>
The rule <a class="info" href="#rule:R9">R9<span>Rule R9</span></a> require certain TC messages to be dismissed because
they are inconsistent with the collected information, and would contaminate
routing tables. The familiarity (see <a class="info" href="#sec:familiarity">Section 4.6<span>Node Familiarity</span></a>) is
at the core of the verification of rule R9.

</p>
<p>
Before further processing a TC , the node MUST first 
checks whether the originator address of the TC is familiar
(as described <a class="info" href="#sec:spec-familiarity">Section 5.4.7<span>Familiarity</span></a>). If and only if,
it is the case, the following steps determine whether the TC processing
should be interrupted according to rule R9:
</p>
<ol class="text">
<li>The number of familiar addresses Nf and the number of 
     unfamiliar addresses Nu is  computed for TC
</li>
<li>If the ratio of familiar addresses is too low, that is precisely if:
    
<blockquote class="text">
<p>Nf &lt (Nf + Nu) * MIN_TC_FAMILIARITY_RATE
</p>
</blockquote><p>
    Then:
    </p>
<ul class="text">
<li>the TC message should be ignored
</li>
</ul>
</li>
</ol>

<a name="rfc.section.5.6.5.4"></a><h4><a name="sec:spec-tc-address-dismiss">5.6.5.4</a>&nbsp;Dismissed addresses in TC messages</h4>

<p>
Upon receiving a TC and prior to TC processing of each address 
according to section 9.5 of the OLSR specification <a class="info" href="#RFC3626">[3]<span>Clausen, T. and P. Jacquet, Optimized Link State Routing Protocol (OLSR), October 2003.</span></a>,
the DAD rules <a class="info" href="#rule:R7">R7<span>Rule R7</span></a> and <a class="info" href="#rule:R8">R8<span>Rule R8</span></a> require some addresses to be ignored to
prevent routing table contamination.

</p>
<p>
In application of the rule <a class="info" href="#rule:R7">R7<span>Rule R7</span></a>, the node SHOULD ignore 
any advertised address in a TC message which verifies the following
conditions simultaneously:
</p>
<ul class="text">
<li>The advertised address is not one interface address of the node, AND
  
</li>
<li>The Originator Address of the TC is familiar 
     (as per <a class="info" href="#sec:spec-familiarity">Section 5.4.7<span>Familiarity</span></a>), AND
  
</li>
<li>The advertised address is familiar
     (as per <a class="info" href="#sec:spec-familiarity">Section 5.4.7<span>Familiarity</span></a>), AND 
  
</li>
<li>There exists no topology tuple where:
    
<ul class="text">
<li>Either T_last_addr == advertised address
</li>
<li>or T_dest_addr == advertised address
</li>
</ul>
</li>
</ul>

<p>
Additionaly, in application of the rule <a class="info" href="#rule:R8">R8<span>Rule R8</span></a>, the node SHOULD ignore 
any advertised address in a TC message which verifies the following
conditions simultaneously:
</p>
<ul class="text">
<li>There exists a neighbor tuple where:
    
<ul class="text">
<li>N_neighbor_main_addr == advertised address, AND
</li>
<li>N_status == SYM
</li>
</ul><p>
     and then,
  
</li>
<li>There exists no two hop tuple where:
    </p>
<ul class="text">
<li>N_neighbor_main_addr == advertised address, AND
</li>
<li>N_2hop_addr == Originator Address
</li>
</ul>
</li>
</ul>

<a name="rfc.section.5.6.6"></a><h4><a name="sec:change-tc-generation">5.6.6</a>&nbsp;Changes in TC Message Generation</h4>

<p>
In order to build the topology information base, each node, which has
been selected as MPR, broadcasts Topology Control (TC) messages in the
OLSR protocol. The following changes should be made in the 
TC message generation of section 9.3 of the OLSR specification <a class="info" href="#RFC3626">[3]<span>Clausen, T. and P. Jacquet, Optimized Link State Routing Protocol (OLSR), October 2003.</span></a>.

</p>
<p>
The conditions for actually generating TC messages, now additionally take into
account the autoconfiguration state
(see <a class="info" href="#sec:state.functionning">Section 4.5.2<span>Functionning</span></a>):
</p>
<ul class="text">
<li>A node SHOULD only generate messages when it is in STATE_NORMAL
</li>
</ul>

<p>
The format of TC messages is different, and hence the TC message generation
should fill properly the extra information:
</p>
<ul class="text">
<li>The Node State field is set such that it corresponds to the
current autoconfiguration state of the node.
</li>
<li>The Neighbor State field is set such that it corresponds to the
autoconfiguration state of all addresses advertised in the TC message.
Namely, for any address which is advertised,
it MUST be advertised in an TC message such that:
  
<ul class="text">
<li>the associated state tuple
       (<a class="info" href="#sec:state-tuple-retrieve">Section 5.4.3<span>Associated State Tuple Retrieval</span></a>) has a S_state
       identical to the Neighbor State of the message
</li>
</ul><p>
As a consequence, one node will send at least as many different TCs
as there are different autoconfiguration states of advertised addresses.

</li>
</ul>
</p>
<p>
Finally, the node MUST keep track of the TCs it has sent, and this is
done by adding information in the duplicate set.
To do so, after the generation of each TC message, the node records
it by creating a duplicate tuple. However due to an address conflict, the
node may already have such a tuple for a received TC from a conflicting
node, hence the two steps update: first check whether there is such
TC, and second, if not, create the duplicate tuple. This is done as
follows, before the TC message is actually sent:
  </p>
<ol class="text">
<li>the message content identifier is computed (as per
          <a class="info" href="#sec:content-identifier">Section 5.2.3.1<span>Message Content Identifier</span></a>)
    
</li>
<li>If there exists a duplicate tuple where:
      
<ul class="text">
<li>D_addr == main address of node
</li>
<li>D_seq_num == TC message sequence number (in message header)
</li>
</ul><p>
      Then the node is in conflict (as an application of rule <a class="info" href="#rule:R4">R4<span>Rule R4</span></a>), and
      </p>
<ul class="text">
<li> it will then stop the processing 
   of the message and it MUST change its address according to the rules of
   <a class="info" href="#sec:spec-address-change">Section 5.3.2<span>Address Change</span></a>
</li>
</ul>
</li>
<li>Otherwise the node creates a duplicate tuple, accordingly to
      <a class="info" href="#sec:special-duplicate">Special Duplicate Tuple
      Creation<span>Special Duplicate Tuple Creation</span></a>.
    
</li>
</ol>

<a name="rfc.section.5.6.7"></a><h4><a name="sec:spec-message-type">5.6.7</a>&nbsp;Message Type for HELLO and TC Messages</h4>

<p>
New message types are introduced by NOA-OLSR, for use with
the new HELLO message format in <a class="info" href="#sec:change-hello-format">Section 5.6.1<span>Changes in HELLO Message Format</span></a>,
and the new TC message format in<a class="info" href="#sec:change-tc-format">Section 5.6.4<span>Changes in TC Message Format</span></a>.
Because these messages simply use "reserved" (blank) fields in standard OLSR
messages, it would be possible to use the standard message types 
HELLO_MESSAGE and TC_MESSAGE.
However for interoperability reasons, a node SHOULD NOT do so.
Instead it should decide first whether it wants to interoperate with standard
OLSR implementations, or not interoperate. 
See <a class="info" href="#sec:interoperability-modified">Section 8.2<span>Interoperability with Standard OLSR</span></a> for a comprehensive
discussion of interoperability with standard OLSR.

</p>
<p>Depending on whether it chooses to interoperate with the standard OLSR
implementations the node, should originate messages as follows:
</p>
<blockquote class="text"><dl>
<dt>Interoperating with standard OLSR:</dt>
<dd>
    The node MUST generate messages with HELLO_MESSAGE type and TC_MESSAGE
    type when the fields "node state" and the "neighbor state" of the message
    are both in state NORMAL. 

    It MUST ignore all the messages with "node state" == NORMAL_STATE
    
    and message type HELLO_WITH_STATE_MESSAGE or TC_WITH_STATE_MESSAGE.
  
</dd>
<dt>Never interoperating with standard OLSR:</dt>
<dd>
    The node MUST generate all HELLO and TC messages with a message type
    of HELLO_WITH_STATE_MESSAGE or TC_WITH_STATE_MESSAGE. 

    It MUST ignore all the messages with message type HELLO_MESSAGE and
    TC_MESSAGE.
  
</dd>
</dl></blockquote>

<a name="rfc.section.5.7"></a><h4><a name="sec:change-mpr-computation">5.7</a>&nbsp;Changes in MPR Computation</h4>

<p>
The MPR computation is changed as follows. First, before any new MPR 
computation, it must be kept track of the previous MPR set, as indicated
in <a class="info" href="#sec:state-mpr-remember">Section 5.4.6<span>State Tuple: MPR information update</span></a>.

</p>
<p>
During MPR computation, the node should avoid any node in a state different
from STATE_NORMAL (as <a class="info" href="#sec:state.functionning">Section 4.5.2<span>Functionning</span></a> specifies).
After the MPR computation has been achieved, yielding a new MPR set, 
this set is completed with the MPR enforced by autoconfiguration
rules (namely rule <a class="info" href="#rule:R12">R12<span>Rule R12</span></a>), as follows:

</p>
<p>The node MUST add to its MPR set, the address S_main_addr of any 
state tuple where:
</p>
<blockquote class="text">
<p>S_main_addr is not already in the newly computed MPR list
</p>
<p>S_MPR_forced_time > current time
</p>
<p>There exists a neighbor tuple in the neighbor set where:
    </p>
<blockquote class="text">
<p>N_neighbor_main_addr == S_main_addr
</p>
<p>N_status == SYM
</p>
</blockquote>

</blockquote>

<a name="rfc.section.5.8"></a><h4><a name="sec:change-routing-table">5.8</a>&nbsp;Changes in Routing Table Calculation</h4>

<p>
Standard routing table calculation is described in section 10 of the OLSR specification <a class="info" href="#RFC3626">[3]<span>Clausen, T. and P. Jacquet, Optimized Link State Routing Protocol (OLSR), October 2003.</span></a>.
However with the introduction of the autoconfiguration state, it should
now be exclusively be performed when the node is in NORMAL_STATE
(see <a class="info" href="#sec:state.functionning">Section 4.5.2<span>Functionning</span></a>).

</p>
<p>
The computed routes should also only have forwarders which are in 
the NORMAL_STATE, and hence the routing table computation algorithm
should be modified.
The property of using only forwarders in the NORMAL_STATE can 
be expressed as ensuring that only route entries where:
  </p>
<blockquote class="text">
<p>R_next_addr is associated to a state tuple (as retrieved by
       <a class="info" href="#sec:state-tuple-retrieve">Section 5.4.3<span>Associated State Tuple Retrieval</span></a>)
         where S_state == NORMAL_STATE
</p>
<p>OR ELSE: R_next_addr == R_dest_addr (i.e. this is a direct neighbor)
</p>
</blockquote>

<p>
This property can be ensured by:
</p>
<ul class="text">
<li>in step 3 of the algorithm of section 10 of the OLSR specification <a class="info" href="#RFC3626">[3]<span>Clausen, T. and P. Jacquet, Optimized Link State Routing Protocol (OLSR), October 2003.</span></a>, 
    using only 2-hop tuples where N_neighbor_main_addr
    is associated to a state tuple (<a class="info" href="#sec:state-tuple-retrieve">Section 5.4.3<span>Associated State Tuple Retrieval</span></a>)
    with S_state == NORMAL_STATE
</li>
<li>in "the second step 3", sub-step 3.1: using only topology tuples where
    T_last_addr is associated to a state tuple 
    (<a class="info" href="#sec:state-tuple-retrieve">Section 5.4.3<span>Associated State Tuple Retrieval</span></a>)
    with S_state == NORMAL_STATE
</li>
</ul>

<a name="sec:constant"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;Proposed Values for Constants</h3>

<p>
The proposed values of the specification are documented here.
Many of them are depend on the constants section 18 of the OLSR specification <a class="info" href="#RFC3626">[3]<span>Clausen, T. and P. Jacquet, Optimized Link State Routing Protocol (OLSR), October 2003.</span></a>.

</p>
<p>
HELLO_STATE_DURATION (= HELLO_INTERVAL)

</p>
<p>
TOPOLOGY_STATE_DURATION (= TC_INTERVAL)

</p>
<p>
MAX_MPR_REMEMBER_TIME (= 2 x NEIGHB_HOLD_TIME)

</p>
<p>
CONFLICT_HOLD_TIME (= NEIGHB_HOLD_TIME)

</p>
<p>
NODE_FAMILIAR_TIME

</p>
<p>
MIN_WRAP_AROUND_INTERVAL (= DUP_HOLD_TIME)

</p>
<p>
MIN_TC_FAMILIARITY_RATE (= 50%)

</p>
<p>
MAX_TC_DIFF_SEQ_NUM, MAX_MESSAGE_RATE

</p>
<p>
NODE_STATE_HOLD_TIME (= 10 x DUP_HOLD_TIME)

</p>
<p></p>
<ul class="text">
<p>Codes for Autoconfiguration State (in messages)
</p>
<li>NORMAL_STATE = 0
</li>
<li>TOPOLOGY_STATE = 1
</li>
<li>HELLO_STATE = 2
</li>
<li>UNDEFINED_STATE = 3
</li>
</ul>

<p>
In this section, several proposed values are dependent on OLSR protocol
values. However, it is allowed in standard OLSR, to change some parameters
(which will result in changes of "validity time" of some messages,
 for instance): then there is an ambiguity about which parameters should be
chosen: the parameters of the receiving node, or the parameters of the
sender node. The values that are proposed here can be used by default, and 
can be replaced by more appropriate values where necessary.

</p>
<a name="sec:message-type-value"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp;IANA Considerations</h3>

<p>
Two new types of control messages are defined in NOA-OLSR.
Because this document is a draft, some values in the range reserved
for private/local use (see section 22 of the OLSR specification <a class="info" href="#RFC3626">[3]<span>Clausen, T. and P. Jacquet, Optimized Link State Routing Protocol (OLSR), October 2003.</span></a>) are proposed:
</p>
<blockquote class="text"><dl>
<dt>HELLO_WITH_STATE_MESSAGE</dt>
<dd>= 130
</dd>
<dt>TC_WITH_STATE_MESSAGE</dt>
<dd>= 131
</dd>
</dl></blockquote><p>
Values in the range 5-127 might be allocated in the OLSR registry 
using standards action, for these new messages.

</p>
<a name="sec:interoperability"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8"></a><h3>8.&nbsp;Limitations and interoperability considerations</h3>

<p>
There are several limitations associated with NOA-OLSR proposed
in this specification. The most important of them is related to the fact
that the node is assumed to work exclusively in an environment where
all nodes have a single interface, but there exists some other minor
limitations which are
explained in <a class="info" href="#sec:limitations-modified">Section 8.1<span>Limitations</span></a>.
The other kind of limitation is a direct consequence of the previous one:
although an implementation of NOA-OLSR will interoperate with most
standard OLSR implementations, some features of standard OLSR
interact negatively, and unconditional interoperability is
not warranted. The conditions of interoperability are documented
in <a class="info" href="#sec:limitations-modified">Section 8.1<span>Limitations</span></a>.

</p>
<a name="rfc.section.8.1"></a><h4><a name="sec:limitations-modified">8.1</a>&nbsp;Limitations</h4>

<p>
The limitations of NOA-OLSR protocol are highlighted in
this document. Some of the limitations will be addressed
in future versions of this document, some are intrinsic to the
method, and may be lifted by added requirements on the OLSR protocol.
In this section, the analysis of these limitations is provided.

</p>
<p>
In this version of this draft, the first one, the duplicate detection
rules have been specified only the most common case, where the node
has a single interface participating in the MANET. This rules can
naturally be extended to integrate multiple interfaces, but doing so
is not immediatly straightforward, and hence will be the subject of
further specification. Meanwhile, an implementation of this specification
of NOA-OLSR cannot be expected to perform reliably with
several interfaces, and more precisely:
  </p>
<ul class="text">
<li>Some duplicate address conflicts will not be detected.
</li>
<li>The assumptions of some rules are no longer verified.
    For instance,
   rule R1 assumes that a node will not receive the HELLO messages that
   it generates.
</li>
<li>The changes in OLSR processing will result, in some cases, in
   a general state of the node (including the data of the miscellaneous
   information repositories) which is inconsistent and
   otherwise impossible in both the standard OLSR and NOA-OLSR. This
   will result in unpredictable behavior.
</li>
</ul>

<p>
Another present restriction derives from the assumption that TC messages
will include only MPR selectors in rule R6. The rule could
be approprietly relaxed, but for any implementation which doesn't, 
in some cases, the node will not interoperate with nodes which 
are advertising more than their MPR selector set. Precisely, these are nodes
which include they auxiliary functionning of "Redundant Topology Information" 
in section 15 of the OLSR specification <a class="info" href="#RFC3626">[3]<span>Clausen, T. and P. Jacquet, Optimized Link State Routing Protocol (OLSR), October 2003.</span></a>
(with TC_REDUNDANCY different from 0, see section 15.1 of the OLSR specification <a class="info" href="#RFC3626">[3]<span>Clausen, T. and P. Jacquet, Optimized Link State Routing Protocol (OLSR), October 2003.</span></a>).

</p>
<p>
Concerning the intrisic restrictions due to the DAD rules, the most noticeable
is the use of message sequence numbers to detect message inconsistency
(as <a class="info" href="#sec:seq-num-consistency">Section 4.4<span>Sequence Number Consistency</span></a>). This assumes, logically,
that the message sequence numbers will be linearily incremented, however
this is property of the standard OLSR is not stated as a "REQUIREMENT". 
Practices such
as computing a sequence number from the content of the message, for instance,
would defeat autoconfiguration mechanisms.

</p>
<p>
Finally, the necessary changes auxiliary functions of OLSR 
(such as for options "Non-OLSR Interfaces", section 12 of the OLSR specification <a class="info" href="#RFC3626">[3]<span>Clausen, T. and P. Jacquet, Optimized Link State Routing Protocol (OLSR), October 2003.</span></a>),
are not addressed in this documente, and the impact of NOA-OLSR
on auxiliary functionning is not addressed for the time being.

</p>
<a name="rfc.section.8.2"></a><h4><a name="sec:interoperability-modified">8.2</a>&nbsp;Interoperability with Standard OLSR</h4>

<p>
A node implementing NOA-OLSR protocol relies on some assumptions
given in the previous <a class="info" href="#sec:limitations-modified">Section 8.1<span>Limitations</span></a>,
hence might not be able to interoperate successfully with a MANET comprising 
given standard OLSR implementations.

</p>
<p>
Two modes of operation are defined in
<a class="info" href="#sec:spec-message-type">Section 5.6.7<span>Message Type for HELLO and TC Messages</span></a>:
</p>
<ul class="text">
<li>a node that never interoperates
with nodes running standard OLSR.
</li>
<li>a node that always interoperates with nodes running the standard OLSR
 protocol.
</li>
</ul><p>
The discussion and logic behind interoperability is found in
<a class="info" href="#sec:interoperability-discussion">Section 8.2.1<span>Considerations for Interoperability with Standard OLSR</span></a>, and the discussion
and logic behind isolation is in <a class="info" href="#sec:isolation">Section 8.2.2<span>Considerations for Isolation from Standard OLSR Nodes</span></a>.

</p>
<a name="rfc.section.8.2.1"></a><h4><a name="sec:interoperability-discussion">8.2.1</a>&nbsp;Considerations for Interoperability with Standard OLSR</h4>

<p>
A sufficient condition for interoperability between two link state routing
protocols running on the same network, is that they both use the same 
topology information and the same algorithm for route calculation,
and also if topology information exchange is not disrupted. This
sufficient condition is verified for the standard OLSR and NOA-OLSR,
when it is implemented as documented here and in
<a class="info" href="#sec:spec-message-type">Section 5.6.7<span>Message Type for HELLO and TC Messages</span></a>. Namely:
</p>
<ul class="text">
<li>When a node is in the NORMAL_STATE, it will advertise all information
  about addresses in NORMAL_STATE inside HELLO and TC messages which are
  compliant with standard OLSR.
</li>
<li>When a node is not in the NORMAL_STATE, or alternatively 
  when it advertises
  information about addresses which are not in NORMAL_STATE, it
  uses messages that the standard OLSR will not process.
</li>
</ul>

<p>
The sufficient conditions are satisfied because:
</p>
<ul class="text">
<li>As the standard OLSR does, NOA-OLSR uses only nodes in the NORMAL_STATE
     for computing routes as forwarders.
  
</li>
<li>MPR flooding is not disrupted, because:
     nodes with NOA-OLSR which are not in 
     NORMAL_STATE are invisible to the standard OLSR. As a result:
    
<ul class="text">
<li>MPR flooding from Sstandard OLSR nodes: standard
   OLSR nodes will never attempt to select as MPR some nodes which are not
   in NORMAL_STATE, hence no problem arises.
</li>
<li>MPR flooding from nodes with NOA-OLSR: nodes implementing NOA-OLSR,
  that are not in NORMAL_STATE, are not selected as MPR.
</li>
</ul>
</li>
</ul>

<p>
Because of some of the current restrictions of NOA-OLSR, it might be
the case that in some networks, one given implementation of modified
OLSR won't interoperate with one given standard OLSR implementation. 
This issue is addressed in the next <a class="info" href="#sec:isolation">Section 8.2.2<span>Considerations for Isolation from Standard OLSR Nodes</span></a>.

</p>
<a name="rfc.section.8.2.2"></a><h4><a name="sec:isolation">8.2.2</a>&nbsp;Considerations for Isolation from Standard OLSR Nodes</h4>

<p>
It may be desired to isolate an implementation
of NOA-OLSR from the standard OLSR networks.
This is a perticuliar instance of the related problem of separating of 
a OLSR, MANET or general network in different administrative entities.

</p>
<p>
In the OLSR protocol, all links between OLSR interfaces are discovered by 
means of neighbor sensing.

Then, isolating one node to another node can be achieved by either of them
ignoring the messages of the other. This results into an asymmetrical link,
which will neither be used for MPR selection, nor MPR flooding nor route
calculation, and in practice, in isolation of the nodes from each other.

</p>
<p>
However doing so, requires generally an external mechanism to exchange
information sufficient for one node to determine whether it want to 
be isolated from another. In the case of NOA-OLSR, this
information is implicitly provided as follows:
</p>
<ul class="text">
<li>A node which doesn't wish to interoperate with standard OLSR,
     should transmit all its HELLO and TC messages with message
     type HELLO_WITH_STATE and TC_WITH_STATE
</li>
<li>A node which wishes to interoperate with standard OLSR, should
     transmit all its HELLO and TC messages, when in STATE_NORMAL,
     ,
     with message type HELLO_MESSAGE and TC_MESSAGE
</li>
</ul><p>

These rules must be respected,
as enforced by <a class="info" href="#sec:spec-message-type">Section 5.6.7<span>Message Type for HELLO and TC Messages</span></a>. 
Note that as a consequence, a node which receives
HELLO message from a node in STATE_NORMAL (or from a standard OLSR node),
can deduce which kind of policy it enforce.

</p>
<a name="anchor13"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9"></a><h3>9.&nbsp;Requirements notation</h3>

<p>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL",
          "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY",
          and "OPTIONAL" in this document are to be interpreted as
          described in <a class="info" href="#RFC2119">[1]<span>Bradner, S., Key words for use in RFCs to Indicate Requirement Levels, March 1997.</span></a>.
</p>
<a name="sec:security"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10"></a><h3>10.&nbsp;Security Considerations</h3>

<p>

As the standard OLSR does not specify any special security measure,
it makes a target for various attacks (see section 20 of the OLSR specification <a class="info" href="#RFC3626">[3]<span>Clausen, T. and P. Jacquet, Optimized Link State Routing Protocol (OLSR), October 2003.</span></a>) ;
NOA-OLSR is subject to the same attacks, 
but also to other attacks:
such as forging
messages in order to deliberatly trigger some DAD rules, hence forcing an 
address
change, or increasing OLSR control traffic. However the conditions in which
such attacks can
be sucessfully conducted are some conditions in which more severe attacks
can be conducted with the standard OLSR protocol. Hence, in practice,
vulnerability of NOA-OLSR protocol against deliberate attacks,
is identical to the vulnerability of the standard OLSR protocol.

</p>
<a name="anchor14"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.11"></a><h3>11.&nbsp;Acknowledgements</h3>

<p>The authors would like to thank  Sota Yoshida, 
Masoto Goto, Takashi Hasegawa for their valuable contributions to NOA-OLSR,
along wth Yasuhiro Owada, and many other students of
Information and Communication Network Laboratory for
other various aspects for developping 
and testing of this protocol.
</p>
<p>(document generation date: Thu Apr 28 02:52:46 2005)
</p>
<a name="rfc.references"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.12"></a><h3>12.&nbsp;References</h3>

<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>12.1&nbsp;Normative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="RFC2119">[1]</a></td>
<td class="author-text"><a href="mailto:sob@harvard.edu">Bradner, S.</a>, "<a href="ftp://ftp.isi.edu/in-notes/rfc2119.txt">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, March 1997 (<a href="ftp://ftp.isi.edu/in-notes/rfc2119.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2119.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2119.xml">XML</a>).</td></tr>
</table>

<a name="rfc.references2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>12.2&nbsp;Informative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="RFC1321">[2]</a></td>
<td class="author-text"><a href="mailto:rivest@theory.lcs.mit.edu">Rivest, R.</a>, "<a href="ftp://ftp.isi.edu/in-notes/rfc1321.txt">The MD5 Message-Digest Algorithm</a>", RFC 1321, April 1992.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3626">[3]</a></td>
<td class="author-text">Clausen, T. and P. Jacquet, "<a href="ftp://ftp.isi.edu/in-notes/rfc3626.txt">Optimized Link State Routing Protocol (OLSR)</a>", RFC 3626, October 2003.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3684">[4]</a></td>
<td class="author-text">Ogier, R., Templin, F. and M. Lewis, "<a href="ftp://ftp.isi.edu/in-notes/rfc3684.txt">Topology Dissemination Based on Reverse-Path Forwarding (TBRPF)</a>", RFC 3684, February 2004.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3561">[5]</a></td>
<td class="author-text">Perkins, C., Belding-Royer, E. and S. Das, "<a href="ftp://ftp.isi.edu/in-notes/rfc3561.txt">Ad hoc On-Demand Distance Vector (AODV) Routing</a>", RFC 3561, July 2003.</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.ietf-manet-dsr">[6]</a></td>
<td class="author-text">Johnson, D., "<a href="http://www.ietf.org/internet-drafts/draft-ietf-manet-dsr-10.txt">The Dynamic Source Routing Protocol for Mobile Ad Hoc Networks (DSR)</a>", draft-ietf-manet-dsr-10 (work in progress), July 2004.</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.ruffino-manet-autoconf-scenarios">[7]</a></td>
<td class="author-text">Ruffino, S., Stupar, P. and T. Clausen, "<a href="http://www.ietf.org/internet-drafts/draft-ruffino-manet-autoconf-scenarios-00.txt">Autoconfiguration in a MANET: connectivity scenarios and technical issues</a>", draft-ruffino-manet-autoconf-scenarios-00 (work in progress), October 2004.</td></tr>
<tr><td class="author-text" valign="top"><a name="ref:pacman">[8]</a></td>
<td class="author-text">Weniger, K., "Passive Duplicate Address Detection in Mobile Ad hoc 
                 Networks", March 2003.</td></tr>
<tr><td class="author-text" valign="top"><a name="ref:mase-autoconf">[9]</a></td>
<td class="author-text">Mase, K., "No Overhead IP Address Autoconfiguration for Mobile
                 Ad Hoc Networks with Proactive Routing", Work in progress.</td></tr>
</table>

<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Authors' Addresses</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Pr. Kenichi Mase</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Information and Communication Network Lab.,Niigata University</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Niigata University</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Niigata 950-2181,   </td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Japan</td></tr>
<tr><td class="author" align="right">Phone:&nbsp;</td>
<td class="author-text">+81 25 262 7446</td></tr>
<tr><td class="author" align="right">EMail:&nbsp;</td>
<td class="author-text"><a href="mailto:mase@ie.niigata-u.ac.jp">mase@ie.niigata-u.ac.jp</a></td></tr>
<tr><td class="author" align="right">URI:&nbsp;</td>
<td class="author-text"><a href="http://www.net.ie.niigata-u.ac.jp/">http://www.net.ie.niigata-u.ac.jp/</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Cedric Adjih</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Information and Communication Network Lab.,Niigata University</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Niigata University</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">(Permanent address: INRIA Domaine de Voluceau, 
	        Rocquencourt, France)</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Niigata 950-2181,   </td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Japan</td></tr>
<tr><td class="author" align="right">EMail:&nbsp;</td>
<td class="author-text"><a href="mailto:cedric@net.ie.niigata-u.ac.jp, cedric.adjih@inria.fr">cedric@net.ie.niigata-u.ac.jp, cedric.adjih@inria.fr</a></td></tr>
</table>
<a name="rfc.index"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Index</h3>
<table>
<tr><td><span class="strong">D</span></td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td>Duplicate Address Detection Rule</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;&nbsp;<a href="#anchor68">R1</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;&nbsp;<a href="#anchor69">R2</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;&nbsp;<a href="#anchor70">R3</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;&nbsp;<a href="#anchor71">R4</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;&nbsp;<a href="#anchor72">R5</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;&nbsp;<a href="#anchor73">R6</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;&nbsp;<a href="#anchor74">R7</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;&nbsp;<a href="#anchor75">R8</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;&nbsp;<a href="#anchor76">R9</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;&nbsp;<a href="#anchor77">R10</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;&nbsp;<a href="#anchor78">R11</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;&nbsp;<a href="#anchor79">R12</a></td></tr>
<tr><td><span class="strong">I</span></td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td>Index</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;&nbsp;<a href="#anchor49">Document structure</a></td></tr>
<tr><td><span class="strong">S</span></td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td>Specification</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;&nbsp;<a href="#anchor80">Busy Address</a></td></tr>
<tr><td><span class="strong">T</span></td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td>terminology</td></tr>
<tr><td>&nbsp;</td><td>&nbsp;&nbsp;<a href="#anchor50">Address Conflict</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;&nbsp;<a href="#anchor54">Autoconfiguration State</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;&nbsp;<a href="#anchor55">Busy Address</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;&nbsp;<a href="#anchor52">Conflicting Address</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;&nbsp;<a href="#anchor53">Conflicting Message</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;&nbsp;<a href="#anchor51">Conflicting Node</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;&nbsp;<a href="#anchor57">DAD Rule</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;&nbsp;<a href="#anchor56">Duplicate Address Detection (DAD)</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;&nbsp;<a href="#anchor60">familiar address</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;&nbsp;<a href="#anchor58">familiar node</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;&nbsp;<a href="#anchor62">Message Content Identifier Generation Method</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;&nbsp;<a href="#anchor61">Message Content Identifier</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;&nbsp;<a href="#anchor63">NOA-OLSR</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;&nbsp;<a href="#anchor64">Routing Table Contamination Avoidance</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;&nbsp;<a href="#anchor65">Sequence Number Consistency</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;&nbsp;<a href="#anchor66">Standard OLSR</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;&nbsp;<a href="#anchor67">TC Generator</a></td></tr>
<tr><td>&nbsp;</td><td>&nbsp;&nbsp;<a href="#anchor59">unfamiliar node</a></td></tr>
</table>
<a name="rfc.copyright"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="bug" align="right"><tr><td class="bug"><a href="#toc" class="link2">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Intellectual Property Statement</h3>
<p class='copyright'>
The IETF takes no position regarding the validity or scope of any
Intellectual Property Rights or other rights that might be claimed
to pertain to the implementation or use of the technology 
described in this document or the extent to which any license 
under such rights might or might not be available; nor does it
represent that it has made any independent effort to identify any
such rights.
Information on the procedures with respect to
rights in RFC documents can be found in BCP 78 and BCP 79.</p>
<p class='copyright'>
Copies of IPR disclosures made to the IETF Secretariat and any
assurances of licenses to be made available,
or the result of an attempt made to obtain a general license or
permission for the use of such proprietary rights by implementers or
users of this specification can be obtained from the IETF on-line IPR
repository at http://www.ietf.org/ipr.</p>
<p class='copyright'>
The IETF invites any interested party to bring to its attention
any copyrights,
patents or patent applications,
or other
proprietary rights that may cover technology that may be required
to implement this standard.
Please address the information to the IETF at ietf-ipr@ietf.org.</p>
<h3>Disclaimer of Validity</h3>
<p class='copyright'>
This document and the information contained herein are provided
on an &quot;AS IS&quot; basis and THE CONTRIBUTOR,
THE ORGANIZATION HE/SHE REPRESENTS OR IS SPONSORED BY (IF ANY),
THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM
ALL WARRANTIES, 
EXPRESS OR IMPLIED,
INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE
INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED
WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.</p>
<h3>Copyright Statement</h3>
<p class='copyright'>
Copyright (C) The Internet Society (2005).
This document is subject to the rights,
licenses and restrictions contained in BCP 78,
and except as set forth therein,
the authors retain all their rights.</p>
<h3>Acknowledgment</h3>
<p class='copyright'>
Funding for the RFC Editor function is currently provided by the
Internet Society.</p>
</body></html>
